{"version":3,"file":"helpers.js","sources":["../utils/helpers.js"],"sourcesContent":["import Axios from \"axios\"\nimport axiosRetry from 'axios-retry'\n\nimport querystring from 'querystring'\n\naxiosRetry(Axios, {\n  retries: 3,\n  retryDelay: axiosRetry.exponentialDelay,\n  onRetry: (count, err, config) => {\n    console.log('Axios retrying: ', count, err, config)\n  }\n})\n\n// same object, but with updated typings.\n// TODO: roll back caching until CORS is fixed everywhere.\n//import { setupCache } from 'axios-cache-interceptor'\n//const axios = setupCache(Axios);\n\nconst axios = Axios\n\nimport dayjs from 'dayjs'\ndayjs.extend(isBetween)\nimport dayjsRecur from 'dayjs-recur'\ndayjs.extend(dayjsRecur)\nimport isBetween from 'dayjs/plugin/isBetween'\n\nimport LinearScale from 'linear-scale'\nimport truncate from 'truncate'\n\nimport * as turf from '@turf/helpers'\nimport turf_distance from '@turf/distance'\nimport turf_boolean from '@turf/boolean-point-in-polygon'\n\nimport * as constants from '../constants/constants.js'\nimport badges from '../dist/badges.json'\n\nimport { getLocationFromPoint, sortLocations, distanceBetweenLocations } from './map'\nimport { getRelatedVibes, getCategoriesByLevel } from './vibes'\nimport { getGroups } from './wordpress'\n\nconst jsonpack = require('jsonpack')\nlet activityCategories = {}\nlet categories_flat = []\nlet cities = []\nlet neighborhoods = []\n\n// Keep track of which API endpoint domain we are using\nexport const getAPIDomain = (mode = null) => {\n  // Use the mode passed in, or the NODE_ENV\n  const env_mode = typeof (process) != 'undefined' && process.env.API_ENV\n  const current_mode = mode\n    ? mode\n    : env_mode\n      ? env_mode\n      : 'production'\n\n  const url_production = 'https://api.vibemap.com'\n  const url_staging = 'https://staging.api.vibemap.com'\n  const url_dev = 'http://localhost:9001'\n\n  const domain = current_mode === 'production'\n    ? url_production\n    : current_mode === 'staging'\n      ? url_staging\n      : url_dev\n\n  return domain\n}\n\nconst api_domain = getAPIDomain() // 'development', 'staging', 'production'\nconst api_version = 'v0.3'\nconst useSearchAPI = true\nconst useSearchAPIEvents = true\n\nconst ApiUrl = `${api_domain}/${api_version}/`\n\n// Filters a list of objects\n// Similar to .filter method of array\nexport const filterList = (\n  list = [{ test: 'test', value: 'foo' }, { test: 'test', value: 'bar' }],\n  searchTerm = 'food', key = 'value', literal = false\n) => {\n  // Generalize the Semantic UI search implementation\n  let results\n  if (literal) {\n    results = list.filter(item => searchTerm === item[key])\n    console.log(\"FILTERLIST CITY RESULT\", literal, searchTerm, results)\n  } else {\n    const re = new RegExp(searchTerm.replace(/[-[\\]{}()*+!<=:?.\\/\\\\^$|#\\s,]/g, '\\\\$&'), 'i')\n\n    const isMatch = (result) => re.test(result[key])\n\n    results = list.filter(item => isMatch(item))\n  }\n  return results\n}\n\nexport const getRandomItem = (list) => {\n  // Get random index value\n  const randomIndex = Math.floor(Math.random() * list.length)\n\n  // Get random item\n  const item = list[randomIndex]\n\n  return item\n}\n\n// TODO: Option to encode / decode\nexport const encodeCardIndex = (row, column) => {\n  // Encode row / column into a decimal for sorting.\n  const index = row + column / 10\n\n  return index\n}\n\n// Counts the number of matches between the two lists and return and integer\nexport const matchLists = (listA, listB) => {\n  let matches = 0\n\n  if (listA.length > 0 && listB.length > 0) {\n    matches = listA.filter((word) => {\n      return listB.includes(word)\n    }).length\n  }\n\n  return matches\n}\n\n// Give a score based on the vibes position in the list.\nexport const rankVibes = (listA, listB) => {\n  let rankings = []\n\n  rankings = listA.map((word) => {\n    let score = 0\n\n    if (listB.includes(word)) {\n      score = listB.length - listB.indexOf(word)\n    }\n\n    return score\n  })\n\n  const average = rankings.reduce((a, b) => a + b, 0) / listB.length\n\n  return average\n}\n\nexport const sortByKey = (a, b) => {\n  console.log('sortByKey (a, b)', a, b)\n  return a\n}\n\nexport const sortByPopularity = (a, b) => {\n  // Sorted by Monthly Search Volumne (MSV)\n  // Handle null or empty msv\n  const aPop = parseInt(a.details.msv ? a.details.msv : 2)\n  const bPop = parseInt(b.details.msv ? b.details.msv : 2)\n\n  return bPop - aPop\n}\n\ntry {\n  const activityCategoriesPacked = require('../dist/activityCategories.zip.json')\n  activityCategories = {\n    activityCategories: jsonpack.unpack(activityCategoriesPacked)\n  }\n\n  categories_flat = activityCategories.activityCategories\n    .sort(sortByPopularity)\n    .map(category => category.name.toLowerCase())\n\n} catch (error) {\n  console.log('Error with packed activityCategories ', error)\n}\n\ntry {\n  const citiesPacked = require('../dist/cities.json')\n  cities = citiesPacked\n\n  const neighborhoodsPacked = require('../dist/neighborhoods.zip.json')\n  neighborhoods = jsonpack.unpack(neighborhoodsPacked)\n} catch (error) {\n  console.log('Error with packed cities or neighborhoods ', error)\n}\n\nexport const sortByArray = (sortedList, sortingArr) => {\n  return sortedList.sort((a, b) => {\n    return sortingArr.indexOf(a) - sortingArr.indexOf(b)\n  })\n}\n\nexport const isClosedToday = (dailyHours) => {\n  return dailyHours.opens === '00:00:00' && dailyHours.closes === '00:00:00'\n}\n\nexport const displayHours = (hours, dayFormat = 'dd') => {\n  let openHours = isOpen(hours)\n  let hasHours = false\n\n  const weeklyHours = hours.find(({ day_of_week }) => day_of_week === 8)\n\n  if (openHours.openEveryday) {\n    let times = []\n    const time =\n      dayjs(openHours.opens).format('ha') +\n      '-' +\n      dayjs(openHours.closes).format('ha')\n    times.push(time)\n\n    let popularFound = hours.find((day) => day.name == 'POPULAR')\n    console.log('Popular at: ', popularFound)\n\n    return times\n  }\n\n  let i = 0\n  let orderedHours = []\n\n  // Check every day of the week.\n  while (i < 7) {\n    let dayFound = hours.filter((day) => day.day_of_week == i)\n    let popularFound = hours.find(\n      (day) => day.day_of_week == i && day.name == 'POPULAR'\n    )\n\n    // TODO: Handle popular vs normal\n    let hasDailyHours = dayFound.length > 0 && dayFound !== undefined\n    let isClosed = false\n\n    if (hasDailyHours) {\n      // Closed days only have one window of time\n      isClosed = isClosedToday(dayFound[0])\n\n      // We have some hours for the place\n      if (!isClosed) hasHours = true\n    }\n\n    //console.log('DEBUG: dayFound ', dayFound, hasDailyHours, isClosed);\n\n    // If found and not closed\n    if (!hasDailyHours || isClosed) {\n      //const displayHours = helpers.displayHours(dayFound)\n      // Will with daily hours if available\n      if (!isClosed && weeklyHours !== undefined) {\n        // Set for current day\n        let time = Object.assign({}, weeklyHours)\n        time.day_of_week = i\n        orderedHours.push([time])\n        //console.log('DEBUG: updated ordered hours ', orderedHours, time);\n      } else {\n        // Include closed days as closed\n        orderedHours.push([{ day_of_week: i, closed: true }])\n        //console.log('DEBUG: updated ordered hours ', orderedHours, ' closed');\n      }\n    } else {\n      // Need to map to include day of week for each value window for day\n      orderedHours.push(dayFound.map(dayHours => {\n        return Object.assign({}, dayHours, { day_of_week: i, closed: false })\n      }))\n    }\n    i++\n  }\n\n  // Then format each day's hours\n  const formatDailyHours = (dailyHours, day = \"Mon\", includeDay = true) => {\n    const opens = dailyHours.opens.split(':')\n    const closes = dailyHours.closes.split(':')\n\n    const has_minutes = opens[1] !== '00' || closes[1] !== '00'\n\n    const dayText = dayjs().day(day).format(dayFormat)\n    const hourFormat = has_minutes ? 'h:mma' : 'ha'\n    const hourText = dayjs().hour(opens[0]).minute(opens[1]).format(hourFormat)\n    const minutesText = dayjs().hour(closes[0]).minute(closes[1]).format(hourFormat)\n    const hoursText = includeDay\n      ? dayText + ': ' + hourText + '-' + minutesText\n      : hourText + '-' + minutesText\n\n    return hoursText\n  }\n\n  // TODO: Add patterns for nicer formating.\n  // TODO: Handle localization and React templates\n  let formattedHours = orderedHours.map(hoursForDay => {\n    // Days can have more than one window of time\n    const dailyHours = hoursForDay[0]\n\n    // Shift days by 1; Monday = 1; Sunday = 0\n    const day = (dailyHours.day_of_week + 1) % 7\n\n    if (dailyHours.closed === true) {\n      return dayjs().day(day).format(dayFormat) + ': ' + 'Closed'\n    } else {\n      let hoursText = formatDailyHours(dailyHours, day)\n\n      // TODO: handle a 3rd or forth window of time; albeit rare\n      const hasMoreTimes = hoursForDay.length > 1\n      if (hasMoreTimes) {\n        const nextHours = hoursForDay[1]\n        const nextText = formatDailyHours(nextHours, day, false)\n        hoursText += '; ' + nextText\n      }\n\n      return hoursText\n    }\n\n  })\n\n  return formattedHours\n}\n\nexport const isOpen = (hours, time = dayjs()) => {\n  const day = time.day()\n  const date = time.format('YYYY-MM-DD')\n  const hour = time.hour()\n\n  if (!hours) return { openNow: false, openToday: false, isPopular: false }\n\n  let dayFound = hours.find(({ day_of_week }) => day_of_week === day)\n\n  // TODO: not true if it's closed one day\n  const hasDailyHours = hours.find(({ day_of_week }) => day_of_week === 8)\n\n  const daysClosed = hours.filter((day) => isClosedToday(day))\n\n  const openEveryday = hasDailyHours !== undefined && daysClosed.length == 0\n\n  // If open everyday and no specific hours for current day\n  if (openEveryday !== undefined && dayFound === undefined) {\n    dayFound = hasDailyHours\n  }\n\n  if (dayFound) {\n    const opens = dayjs(date + ' ' + dayFound.opens)\n    const closes = dayjs(date + ' ' + dayFound.closes)\n\n    // Return if open and if it's a popular time\n    const openNow = time.isBetween(opens, closes)\n    const isPopular = openNow && dayFound.name === 'POPULAR'\n    const hoursToday = opens.format('ha') + ' - ' + closes.format('ha')\n\n    return {\n      openNow: openNow,\n      openToday: true,\n      openEveryday: openEveryday,\n      opens: opens,\n      closes: closes,\n      isPopular: isPopular,\n    }\n  } else {\n    return {\n      openNow: false,\n      openToday: false,\n      openEveryday: false,\n      isPopular: false,\n    }\n  }\n}\n\nexport const parseDateTime = (datetime) => {\n  const date = datetime ? dayjs(datetime) : null\n  return date\n}\n\nexport const formatDateTime = (\n  datetime,\n  formatHtml = false,\n  showDayOfWeek = false\n) => {\n  if (datetime) {\n    if (typeof (datetime) == 'string') datetime = parseDateTime(datetime)\n\n    const month = datetime.format('MMM')\n    const day = datetime.format('D')\n    const weekday = datetime.format('ddd')\n    const hour = datetime.format('ha')\n    const dateFormated = `${showDayOfWeek ? weekday : null} ${month} ${day} ${hour}`\n\n    return dateFormated\n  } else {\n    return null\n  }\n}\n\nexport const getCardOptions = (block) => {\n  let postData = block.singCards.posts\n\n  let {\n    categoryQuery,\n    distanceQuery,\n    geoQuery,\n    placeType,\n    searchQuery,\n    vibeQuery } = postData[0]\n\n  // If a vibe override query is present\n  if (block.overrideQuery && block.overrideQuery.vibe) vibeQuery = block.overrideQuery.vibe\n\n  // Use city as a back up\n  if (block.overrideQuery && block.overrideQuery.cities && block.overrideQuery.cities.length > 0) {\n    const selectedCity = cities.filter(result => result.slug === block.overrideQuery.cities[0])\n\n    // TODO: Update this programatically from Wordpress\n    const cityRadius = 7\n    geoQuery = geoQuery ? geoQuery : selectedCity[0].location\n    distanceQuery = distanceQuery ? distanceQuery : cityRadius\n  }\n\n  if (block.overrideQuery && block.overrideQuery.location) {\n    geoQuery = block.overrideQuery.location\n\n    distanceQuery = block.overrideQuery.distance ? block.overrideQuery.distance : distanceQuery\n  }\n\n  // If no city or override are passed, make Oakland default\n  if (!geoQuery) {\n    const firstCity = cities.filter(result => result.slug === 'oakland')\n    geoQuery = firstCity[0].location\n  }\n\n  if (typeof vibeQuery === 'string') vibeQuery = vibeQuery.replace(/\\s/g, '').split(\",\") // Cast comma-separated list to array\n\n  // Map all the vibe slug to a list that includes related vibes.\n  const vibesFromCategories = vibeQuery ? vibeQuery.map(vibe => typeof (vibe) === 'string' ? vibe : vibe.slug) : []\n\n  // TODO: Move get relateed vibes to the backend or front end, not here.\n  //const allVibes = vibes.getRelatedVibes(vibesFromCategories)\n\n  let cardOptions = {\n    category: categoryQuery,\n    distance: distanceQuery,\n    point: geoQuery.longitude + ',' + geoQuery.latitude,\n    ordering: 'vibe',\n    search: searchQuery,\n    vibes: vibesFromCategories\n  }\n\n  return cardOptions\n}\n\nexport const getAPIParams = (\n  options,\n  includeRelated = false,\n  useElastic = useSearchAPI\n) => {\n  let { activity, bounds, distance, per_page, point, tags, vibes } = options\n  let params = Object.assign({}, options)\n\n  let distanceInMeters = 1\n  if (distance > 0)\n    distanceInMeters = Math.round(distance * constants.METERS_PER_MILE)\n\n  // API currently doesn't support other options\n  // However, the sorting algorithm, will use them\n  params['ordering'] = options.ordering\n    ? options.ordering\n    : '-aggregate_rating'\n\n  const coords = point && point.split(',')\n  const lat = coords && coords[1]\n  const lon = coords && coords[0]\n  const hasCoords = lat && lon\n\n  if (useElastic) {\n    if (params.activity) {\n      params['categories'] = activity\n    }\n\n    if (params.tags && params.tags.length > 0) {\n      params['tags.raw__wildcard'] = `*${tags}*`\n      delete params['tags']\n    }\n\n    if (params.vibes) {\n      params['vibes'] = vibes\n    }\n\n    if (params.category) {\n      params['categories'] = typeof (params.category) === 'string'\n        ? params.category.toLowerCase().split()\n        : params.category\n    }\n\n    if (hasCoords && params.distance || bounds) {\n      // TOOD: make bounds array into a string like this: 40,-70__30,-80__20,-90\n      // Drop last point and join\n      const bounds_query = bounds\n        ? bounds.map(point => {\n          // Note if this is a reference, it cause all types of problems with the data\n          const new_point = [...point].reverse().join(',')\n          return new_point\n        }).join('__')\n        : null\n\n      bounds && bounds.length > 0\n        ? params['location__geo_polygon'] = bounds_query\n        : params['location__geo_distance'] = `${distanceInMeters}m__${lat}__${lon}`\n\n      delete params['distance']\n    }\n\n    if (params.start_date || params.start_date_after) {\n      const date_time = params.start_date ? params.start_date : params.start_date_after\n      const date_start = dayjs(date_time).startOf('day').format('YYYY-MM-DDTHH:mm:ss')\n      params['end_date__gte'] = date_start\n      delete params['start_date']\n      //delete params['start_date_after']\n    }\n\n    if (params.end_date || params.end_date_before) {\n      const date_time = params.end_date ? params.end_date : params.end_date_before\n      const date_end = dayjs(date_time).endOf('day').format('YYYY-MM-DDTHH:mm:ss')\n      // FIXME: this doens't work for ongoing events\n      params['start_date__lte'] = date_end\n      delete params['end_date']\n      delete params['end_date_before']\n    }\n\n    if (params.search && params.search.length > 0) {\n      // FIXME: Make sure searchess ues the right ordering method in Elastic\n      // FIXME: Check if search term matches any tags or categories with a high thresdhold\n      let example_tag = 'east bay open studios'\n      if (example_tag.includes(params.search)) {\n        params.editorial_category = \"EastBayOpenStudios\"\n      }\n      delete params['ordering']\n      delete params[':vibes.raw__in']\n    }\n\n    if (params.editorial_category) {\n      const term = params.editorial_category\n      params['editorial_categories.raw__wildcard'] = `*${term}*`\n      delete params['editorial_category']\n    }\n\n    if (params.per_page) {\n      params['page_size'] = per_page\n      delete params['per_page']\n    }\n\n    // Add cache busting param, every 5 minutes\n    params['cache_bust'] = Math.floor(Date.now() / 1000 / 60 / 5)\n\n    params['is_approved'] = options.is_approved ? options.is_approved : false\n    params['is_chain'] = options.is_chain ? options.is_chain : false\n    params['is_closed'] = options.is_closed ? options.is_closed : false\n    params['is_destination'] = options.is_destination ? options.is_destination : false\n\n    // TODO: there's probably an easier way to set these rules on the backend.\n    if (params.city) {\n      params['city.raw__contains'] = params.city\n      delete params['city']\n    }\n\n  }\n\n  // Rename args\n  if (activity !== 'all' && activity !== null) params['category'] = activity\n  params['dist'] = distanceInMeters\n  delete params['activity']\n  delete params['distance']\n  delete params['bounds']\n\n  // Cleanup empty args\n  if (params.city == null) delete params['city']\n  if (params.category == null || params.category == 'all' || params.category.length == 0) delete params['category']\n  if (params.editorial_category == null) delete params['editorial_category']\n  if (params.search == null) delete params['search']\n  if (params.vibes == null || params.vibes.length == 0) delete params['vibes']\n  if (includeRelated == false) delete params['relatedVibes']\n  //console.log('distanceInMeters', distanceInMeters, params['dist'])\n\n  return params\n}\n\n// Return all matching Vibemap categories\nexport const getCategoryMatch = (categories = ['all']) => {\n  const all_categories = activityCategories.activityCategories.map(\n    (category) => category.slug\n  )\n\n  let matches = []\n  /* TODO: use a combination of filter & map */\n  categories.map((category) => {\n    if (all_categories.includes(category)) {\n      matches.push(category)\n    }\n    return true\n  })\n\n  return matches\n}\n\n// Parse all variety of social links and return a consistent, valid url\nexport const getFullLink = (link, type = 'instagram') => {\n  const domains = {\n    instagram: 'https://instagram.com/',\n    twitter: 'https://twitter.com/',\n    facebook: 'https://facebook.com/',\n  }\n\n  // Handle things that aren't valid string handles\n  // TODO: add unit tests for link = null; link = '' and other cases\n  if (link === null || link === '') return null\n\n  const parse_url = url.parse(link)\n\n  // TODO: Just use the native URL methods:\n  let url = new URL(link)\n  //const path = url.pathname\n\n\n  // Only the path handle\n  const path = parse_url.path.replace('/', '')\n\n  // Combine domain and handle\n  const full_link = domains[type] + path\n\n  return full_link\n}\n\n// Give a city object return it's center coordinates as an array\nexport const geLocationFromCity = (city) => {\n  // Handles both the object form the CMS and vibemap-constants\n  // TODO: Consolidate to just vibemap-constants\n  const centerPoint = city.cityDetails\n    ? city.cityDetails.placemarker\n    : city.location\n      ? city.location\n      : null\n\n  return centerPoint\n}\n\nexport const getMax = (items, attribute) => {\n  let max = 0\n  items.forEach((item) => {\n    let value = item['properties'][attribute]\n    if (value > max) {\n      max = value\n    }\n  })\n\n  return max\n}\n\nexport const getMin = (items, attribute) => {\n  let min = 100\n  items.forEach((item) => {\n    let value = item['properties'][attribute]\n    if (value < min) {\n      min = value\n    }\n  })\n\n  return min\n}\n\n// Adapted from https://gist.github.com/James1x0/8443042\nexport const getTimeOfDay = (time) => {\n  var time_of_day = null //return g\n\n  //if we can't find a valid or filled moment, we return.\n  if (!time || !time.isValid()) {\n    return\n  }\n\n  var split_afternoon = 12 // 24hr time to split the afternoon\n  var split_evening = 17 // 24hr time to split the evening\n  var currentHour = parseFloat(time.format('HH'))\n\n  if (currentHour >= split_afternoon && currentHour <= split_evening) {\n    time_of_day = 'afternoon'\n  } else if (currentHour >= split_evening) {\n    time_of_day = 'evening'\n  } else {\n    time_of_day = 'morning'\n  }\n\n  return time_of_day\n}\n\n\nconst getTopLocations = (places, location_type = 'city', flat = false) => {\n  let top_locations = {};\n\n  places.map(place => {\n    // Only use city name, not state or country\n    const location = place.properties[location_type]\n\n    if (location != null && location != 'null') {\n      const name = location.split(',')[0]\n\n      if (top_locations.hasOwnProperty(location)) {\n        top_locations[name] += 1;\n      } else {\n        top_locations[name] = 1;\n      }\n    }\n\n    return null\n  });\n\n  var sortable = [];\n  for (var location in top_locations) {\n    sortable.push([location, top_locations[location]]);\n  }\n\n  let top_locations_sorted = sortable.sort(function (a, b) {\n    return b[1] - a[1]\n  });\n\n  const locations = flat\n    ? top_locations_sorted.map((location) => location[0])\n    : top_locations_sorted\n  return locations\n}\n\n// TODO: consolidate with getTopVibes; can be generic for any property with array values\nexport const getTopTags = (places, flat = false) => {\n  let top_tags = {}\n\n  places.map((place) => {\n    place.properties.tags.map(tag => {\n      if (top_tags.hasOwnProperty(tag)) {\n        top_tags[tag] += 1\n      } else {\n        top_tags[tag] = 1\n      }\n      return null\n    })\n    return null\n  })\n\n  var sortable = []\n  for (var tag in top_tags) {\n    sortable.push([tag, top_tags[tag]])\n  }\n\n  let top_tags_sorted = sortable.sort(function (a, b) {\n    return b[1] - a[1]\n  })\n\n  const tags = flat ? top_tags_sorted.map(tag => tag[0]) : top_tags_sorted\n  return tags\n}\n\n\nexport const getTopVibes = (places, flat = false) => {\n  let top_vibes = {}\n\n  places.map((place) => {\n    place.properties.vibes.map((vibe) => {\n      if (top_vibes.hasOwnProperty(vibe)) {\n        top_vibes[vibe] += 1\n      } else {\n        top_vibes[vibe] = 1\n      }\n      return null\n    })\n    return null\n  })\n\n  var sortable = []\n  for (var vibe in top_vibes) {\n    sortable.push([vibe, top_vibes[vibe]])\n  }\n\n  let top_vibes_sorted = sortable.sort(function (a, b) {\n    return b[1] - a[1]\n  })\n\n  const vibes = flat ? top_vibes_sorted.map((vibe) => vibe[0]) : top_vibes_sorted\n\n  return vibes\n}\n\n// Rank/count categories for places and events\nexport const getTopCategories = (places, attribute = 'categories') => {\n  let top_categories = {};\n\n  places.map((place) => {\n    place.properties[attribute].map((item) => {\n      if (top_categories.hasOwnProperty(item)) {\n        top_categories[item] += 1;\n      } else {\n        top_categories[item] = 1;\n      }\n      return null\n    });\n    return null\n  });\n\n  var sortable = [];\n  for (var item in top_categories) {\n    sortable.push([item, top_categories[item]]);\n  }\n\n  let top_categories_sorted = sortable.sort(function (a, b) {\n    return b[1] - a[1]\n  });\n\n  return top_categories_sorted\n}\n\nexport const getWaveFromVibe = (vibe) => {\n  switch (vibe) {\n    case 'buzzing':\n      return 'high'\n    default:\n      return 'medium'\n  }\n\n  //console.log('Get wave level for vibe: ', vibe, waveLevel)\n\n  return waveLevel\n}\n\nexport const graphToEvents = (edges = []) => {\n  const events = edges.map(edge => {\n    const groupEvent = edge.node\n    const details = groupEvent.groupDetails\n\n    const name = details.name\n    const link = details.link\n    const slug = groupEvent.slug\n    const description = details.description\n    // TODO: Handle multiple images\n    const image = details.image\n      ? details.image.url\n      : null\n    const images = [{\n      url: image,\n      original: image\n    }]\n    const location = details.map\n    const price = details.price ?\n      details.price :\n      `free`\n\n    const vibes = details.vibes ?\n      details.vibes.map(vibe => vibe.slug) : []\n\n    const recurring = details.recurring\n    const recurrence = details.recurrence\n    const which = details.which\n    const day = details.day.value\n\n    const startTime = details.startTime ?\n      details.startTime :\n      `00:00`\n    const endTime = details.startTime ?\n      details.endTime :\n      `00:00`\n\n    const recurRule = nextDateFromRecurring(recurrence, day, which)\n\n    const nextStartTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, startTime))\n\n    const nextEndTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, endTime))\n\n    const event = {\n      id: slug,\n      title: name,\n      geometry: {\n        type: \"Point\",\n        coordinates: [-122.26747099999956, 37.81396520000001]\n      },\n      dateTime: nextStartTime,\n      image: images,\n      card_type: 'event',\n      properties: {\n        name: name,\n        title: name,\n        url: link,\n        address: location && location.streetAddress,\n        categories: [],\n        city: details.cities && details.cities[0].slug,\n        description: description,\n        is_online: false,\n        images: [],\n        hotspots_place: location,\n        location: location,\n        start_date: nextStartTime,\n        end_date: nextEndTime,\n        vibemap_images: images,\n        likes: 10,\n        price: price,\n        recurs: true,\n        vibes: vibes\n      }\n    }\n\n    return event\n  })\n\n  return events\n}\n\nexport const groupsToEvents = (groups = []) => {\n  const events = groups.map(groupEvent => {\n    //const groupEvent = edge.node\n    const details = groupEvent.acf\n\n    const name = details.name\n    const link = details.link\n    const slug = groupEvent.slug\n    const description = details.description\n    // TODO: Handle multiple images\n    const image = details.image && details.image.url\n    const images = image\n      ? [{\n        url: image,\n        original: image\n      }]\n      : []\n\n    const location = details.map\n    const price = details.price ?\n      details.price :\n      `free`\n\n    const vibes = details.vibes ?\n      details.vibes.map(vibe => vibe.slug) : []\n\n    const recurring = details.recurring\n    const recurrence = details.recurrence\n    const which = details.which\n    const day = details.day && details.day.label\n      ? details.day.label\n      : `sunday`\n\n    const startTime = details.start_time ?\n      details.start_time :\n      `00:00`\n    const endTime = details.end_time ?\n      details.end_time :\n      `00:00`\n\n    const recurRule = nextDateFromRecurring(recurrence, day, which)\n\n    const nextStartTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, startTime))\n\n    const nextEndTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, endTime))\n\n    const event = {\n      id: slug,\n      title: name,\n      geometry: {\n        type: \"Point\",\n        coordinates: [-122.26747099999956, 37.81396520000001]\n      },\n      dateTime: nextStartTime.toISOString(),\n      image: images,\n      card_type: 'event',\n      properties: {\n        name: name,\n        title: name,\n        url: link,\n        address: location && location.streetAddress,\n        categories: [],\n        city: details.cities && details.cities[0].slug,\n        description: description,\n        is_online: false,\n        images: images,\n        hotspots_place: location,\n        location: location,\n        start_date: nextStartTime.toISOString(),\n        end_date: nextEndTime.toISOString(),\n        vibemap_images: images,\n        likes: 10,\n        price: price,\n        recurs: true,\n        vibes: vibes\n      }\n    }\n\n    return event\n  })\n\n  return events\n}\n\n// This function is no longer utilized. Linear scale from 0 to 10\nexport const normalize = (val, min, max) => {\n  return ((val - min) / (max - min)) * 10\n}\n\n/* New flexible linear scaling function. Using d3.scaleLinear, a value (val) between\nmin and max is scaled appropriately to value between scale_low and scale_high\n*/\nexport const normalize_all = (val = 500, min = 1, max = 100, scale_low = 1, scale_high = 10) => {\n\n  const scale = LinearScale().domain([min, max]).range([scale_low, scale_high])\n  //console.log(`linear-scale result `, scale(val))\n\n  return scale(val)\n}\n\n// TODO Function for scaling icon. Currently bug (likely in clustering) where certain icon's become very small\nexport const scaleIconSize = (score = 5, min = 1, max = 100) => {\n  const minSize = 1\n  const maxSize = 5\n\n  // TODO: Test and replace\n  //const d3_scale = scaleLinear().domain([min, max]).range([1, 5])\n\n  const scale = LinearScale()\n    .domain([min, max])\n    .range([minSize, maxSize])\n\n  const iconSize = scale(score)\n\n  return iconSize\n}\n\nexport const scaleMarker = (score = 50, min = 0, max = 100, zoom = 14) => {\n  // TODO: Hack to catch empty/nan scores\n  if (isNaN(score)) score = 3.5\n\n  const marker_scale = LinearScale()\n    .domain([8, 20])\n    .range([10, 30])\n\n\n  let base_marker = marker_scale(zoom)\n  let max_marker = base_marker * 3\n\n  let scale = LinearScale()\n    .domain([0, max])\n    .range([base_marker, max_marker])\n\n  let scaled_size = Math.round(scale(score))\n\n  return scaled_size\n}\n\n// Maps the relative density of place to a known range for Vibemap's cities\nexport const scaleDensityArea = (density = 10, area = 100) => {\n  // TODO: Make these contants?\n  let density_scale = LinearScale()\n    .domain([1, 60, 1000])\n    .range([0, 0.8, 1])\n\n  let relative_density = density_scale(density)\n\n  return relative_density\n}\n\nexport const scaleDensityBonus = (relative_density) => {\n  let inverted_scale = LinearScale()\n    .domain([0, 1])\n    .range([constants.HEATMAP_INTENSITY * 2, constants.HEATMAP_INTENSITY])\n\n  const withBonus = inverted_scale(relative_density)\n  return withBonus\n}\n\nexport const scaleScore = (score = 2) => {\n  let scale = LinearScale()\n    .domain([0, 5])\n    .range([60, 100])\n\n  let percentage = Math.round(scale(score))\n\n  return percentage\n}\n\nexport const scaleSelectedMarker = (zoom) => {\n  // Scale em size of svg marker to zoom level\n  let scale = LinearScale()\n    .domain([8, 12, 20]) // Zoom size\n    .range([0.1, 1.2, 4]) // Scale of marker size\n\n  let scaled_size = Math.round(scale(zoom))\n\n  return scaled_size\n}\n\nexport const isDateFormatYYYYMMDD = (str) => {\n  const regex = /^\\d{4}-\\d{2}-\\d{2}$/;\n  return regex.test(str);\n}\n\nexport const getDatesFromRange = (date_range = 'weekend', start_date = null) => {\n  let start_date_formated = start_date\n  if (start_date_formated) {\n    // Check if it's a string is 'YYYY-MM-DD' or 'DD-MM-YYYY\n    const start_date_slashes = start_date && typeof start_date === 'string'\n      ? start_date.replace(/-/g, '/')\n      : start_date;\n    const start_with_year = isDateFormatYYYYMMDD(start_date_slashes)  // true\n    start_date_formated = dayjs(start_date_slashes).format(start_with_year ? 'YYYY/MM/DD' : 'MM/DD/YYYY');\n  }\n\n  // Set hours and minute to 00:00\n  const today = start_date_formated\n    ? dayjs(start_date_formated).startOf('day')\n    : dayjs().startOf('day')\n\n  const dayOfWeek = today.day() + 1\n\n  let startOffset = 0\n  let endOffset = 0\n\n  switch (date_range) {\n    case 'day':\n      endOffset = 1\n      break;\n\n    case 'weekend':\n      endOffset = 7 - dayOfWeek\n      break;\n\n    case 'next_week':\n      startOffset = 8 - dayOfWeek\n      endOffset = 7\n      break;\n\n    case 'month':\n      const monthEnd = today.endOf('month')\n      endOffset = monthEnd.diff(today, 'day')\n      break;\n\n    case 'quarter':\n      endOffset = 90\n      break;\n\n    case 'half_year':\n      endOffset = 180\n      break;\n\n    case 'year':\n      endOffset = 360\n      break;\n  }\n\n  let date_range_start = today.add(startOffset, 'day').startOf('day')\n  let date_range_end = today.add(endOffset, 'day').endOf('day') //  TODO Plus range\n\n  return {\n    start: date_range_start,\n    end: date_range_end\n  }\n}\n\n\nexport const getEventOptions = (\n  city = 'oakland',\n  date_range = 'quarter',\n  distance = 10,\n  category = null,\n  vibes = [],\n  search,\n  tags = [],\n  start_date_custom = null,\n  end_date_custom = null,\n  page = 1,\n  per_page = 200\n) => {\n  let location = null\n  if (typeof city == 'string') {\n    const locations = cities.concat(neighborhoods)\n    const selectedLocation = locations.filter(result => result.slug === city)\n    // FIXME: Why is the location sometimes missing\n    location = selectedLocation && selectedLocation.length > 0\n      ? selectedLocation[0].location\n      : cities[0]\n  } else {\n    location = city.location\n  }\n\n  // Fix for Safari bug\n  const has_dashes = start_date_custom && typeof start_date_custom === 'string' ? start_date_custom.includes('-') : false;\n  const format = has_dashes\n    ? 'YYYY-MM-DD HH:mm'\n    : 'MM/DD/YYYY HH:mm'\n\n  // Use custom range or calculate start end from shortcut\n  const start_date_formated = has_dashes && start_date_custom\n    ? start_date_custom.replace(/-/g, '/')\n    : start_date_custom\n\n  const end_date_formated = end_date_custom && has_dashes\n    ? end_date_custom.replace(/-/g, '/')\n    : end_date_custom\n\n  const startAndEnd = getDatesFromRange(date_range, start_date_formated)\n  const date_range_start = start_date_custom\n    ? dayjs(start_date_formated)\n    : startAndEnd.start\n\n  const date_range_end = end_date_custom\n    ? dayjs(end_date_formated)\n    : startAndEnd.end\n\n  const start_date_after = date_range_start.format(format)\n\n  let options = {\n    activity: category,\n    category: category,\n    distance: distance,\n    point: location.longitude + ',' + location.latitude,\n    ordering: '-score_combined',\n    start_date_after: start_date_after,\n    end_date_before: date_range_end.format(format),\n    page: page,\n    per_page: per_page,\n    search: search,\n    tags: tags,\n    vibes: vibes\n  }\n\n  // Don't pass empty/null params\n  if (options.category == null || options.category == 'all' || options.category.length == 0) delete options['category']\n  if (options.search == null) delete options['search']\n  if (options.tags == null || options.tags.length == 0) delete options['tags']\n  if (options.vibes == null || options.vibes.length == 0) delete options['vibes']\n\n  return options\n}\n\nexport const fetchEvents = async (\n  // Defaults for testing\n  options = {\n    distance: 20,\n    page: 1,\n    point: `-122.269994,37.806507`\n  },\n  activitySearch = false,\n  recurringSearch = false\n) => {\n  //console.log('fetchEvents: activitySearch, recurringSearch', activitySearch, recurringSearch);\n\n  let {\n    activity,\n    bounds,\n    category,\n    days,\n    distance,\n    ordering,\n    page,\n    point,\n    search,\n    time,\n    vibes,\n  } = options\n\n  console.log('DEBUG: fetchEvents > getAPIParams ', options);\n\n  let centerPoint = point.split(',').map((value) => parseFloat(value))\n  let currentLocation = getLocationFromPoint(centerPoint)\n  let distanceInMeters = distance * constants.METERS_PER_MILE\n\n  let day_start = dayjs().startOf('day').format('YYYY-MM-DD HH:MM')\n  let day_end = dayjs().add(days, 'days').format('YYYY-MM-DD HH:MM')\n\n  if (activitySearch && category) {\n    options.search = `${category ? category : ''} ${search ? search : ''}`\n  }\n\n  const nearestCities = sortLocations(cities, currentLocation)\n  const city = nearestCities && nearestCities.length > 0\n    ? nearestCities[0].name\n    : null\n\n  const params = module.exports.getAPIParams(options, undefined, undefined, useSearchAPIEvents)\n  //const searchParams = new URLSearchParams(params)\n  //let query = searchParams.toString()\n  let query = querystring.stringify(params)\n\n  const apiEndpoint = useSearchAPI && useSearchAPIEvents\n    ? ApiUrl + 'search/events'\n    : ApiUrl + 'events/'\n\n  const source = axios.CancelToken.source()\n\n  let response = await axios.get(`${apiEndpoint}?${query}`, {\n    cancelToken: source.token,\n  }).catch(function (error) {\n    // handle error\n    console.log('Axios error ', error.response && error.response.statusText)\n\n    return {\n      data: [],\n      count: 0,\n      top_categories: [],\n      top_locations: [],\n      top_tags: [],\n      top_vibes: [],\n      loading: false,\n      timedOut: false\n    }\n  })\n\n  // TODO: How to filter by location and category / vibe\n  if (recurringSearch) {\n    const groups = await getGroups({ city: city ? city : '' })\n    const recurringGroupEvents = groupsToEvents(groups.data)\n\n    response.data.results.features = recurringGroupEvents.concat(response.data.results.features)\n  }\n\n  const events = response.data.results.features\n  const top_categories = getTopCategories(events)\n  const top_tags = getTopTags(events)\n  const top_vibes = getTopVibes(events)\n  const top_locations = getTopLocations(events)\n\n  const results = {\n    ...response,\n    count: response.data.count,\n    top_categories: top_categories,\n    top_locations: top_locations,\n    top_tags: top_tags,\n    top_vibes: top_vibes,\n    loading: false,\n    timedOut: false\n  }\n\n  return results\n}\n\nconst nextDateFromRecurring = (...[\n  recurrence,\n  day,\n  which\n]) => {\n  const date = dayjs() // .startOf('month')\n  const ordinals = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\"]\n  const whichDay = ordinals.indexOf(which)\n  const weekOfMonth = whichDay > 0 ? whichDay : 0\n\n  // TODO: Handle daily, quarterly, yearly\n  // And pass this same util to the details page\n  const recurRule = recurrence == `monthly` ?\n    date.recur()\n      .every(day).daysOfWeek() // By day name\n      .every([weekOfMonth]).weeksOfMonthByDay() // By which week of the month\n    :\n    date.recur()\n      .every(day).daysOfWeek() // Same day every week\n\n  return recurRule\n}\n\nexport const fetchPlacesDetails = async (id, type = 'place') => {\n  const source = axios.CancelToken.source()\n  let apiEndpoint\n  let category = \"\"\n\n  if (type == \"event\") {\n    apiEndpoint = `${ApiUrl}events/`\n    category = `Event`\n  }\n\n  if (type == \"place\") {\n    apiEndpoint = `${ApiUrl}places/`\n    category = `Place`\n  }\n\n  if (apiEndpoint) {\n    const response = await axios.get(`${apiEndpoint}${id}`, {\n      cancelToken: source.token,\n    }).catch(function (error) {\n      // handle error\n      console.log('axios error ', error && error.statusText);\n      return null\n    })\n\n    let subcategory = category\n\n    return response\n  }\n}\n\n// Fetch Places from API with query params including\n// - categories\n// - vibes\n// - search\nexport const fetchPlacePicks = async (\n  options = {\n    distance: 5,\n    point: '-123.1058197,49.2801149',\n    ordering: '-score_combined',\n    tags: [],\n    vibes: ['chill'],\n    preferredVibes: [],\n    relatedVibes: [] // TODO: Separate query by * score by\n  }\n) => {\n  let {\n    activity,\n    bounds,\n    category,\n    days,\n    distance,\n    is_chain = false,\n    is_closed = false,\n    is_destination = false,\n    ordering,\n    per_page,\n    point,\n    search,\n    time,\n    tags,\n    vibes,\n    preferredVibes,\n    relatedVibes,\n    shouldSort = true,\n    useNearest = false,\n    useBoundaries = false\n  } = options\n\n  let distanceInMeters = 1\n  if (distance > 0) distanceInMeters = distance * constants.METERS_PER_MILE\n  if (activity === 'all') activity = null\n\n  const scoreBy = ['aggregate_rating', 'vibes', 'distance', 'offers', 'hours']\n  const numOfPlaces = per_page ? per_page : 400\n  const hasVibes = vibes && vibes.length > 0\n\n  let centerPoint = point.split(',').map((value) => parseFloat(value))\n  let currentLocation = getLocationFromPoint(centerPoint)\n  const nearestCities = sortLocations(cities, currentLocation)\n  const distanceFrom = distanceBetweenLocations(nearestCities[0].location, currentLocation)\n\n  // Use city if nearby, for better caching\n  if (useNearest && distanceFrom < 20) {\n    const city = nearestCities[0]\n    options.point = city.centerpoint.join(',')\n    options.city = city.slug\n  }\n\n  const apiEndpoint = useSearchAPI\n    ? ApiUrl + 'search/places'\n    : ApiUrl + 'places/'\n\n  // Cancel previous request\n  const source = axios.CancelToken.source()\n  let response = {}\n\n  const getPlaces = async (options) => {\n    const params = getAPIParams(options, numOfPlaces)\n    let query = querystring.stringify(params)\n    //console.log(`Places search query is `, `${apiEndpoint}?${query}`);\n\n    response = await axios.get(`${apiEndpoint}?${query}`, {\n      cancelToken: source.token,\n    }).catch(function (error) {\n      // handle error\n      console.log('axios error ', error.response && error.response.statusText);\n\n      return {\n        data: [],\n        count: 0,\n        query: '?' + query,\n        top_vibes: null,\n        loading: false,\n        timedOut: false,\n      }\n    })\n\n    return response\n  }\n\n  response = await getPlaces(options)\n\n  const count = response.data.count\n\n  // FIXME: Workaround to retry with search\n  if (count == 0 && hasVibes) {\n    let newOptions = Object.assign({}, options)\n    newOptions.search = vibes[0]\n    newOptions.vibes = []\n\n    response = await getPlaces(newOptions)\n    //response = await\n  }\n\n  const placeResults = response.data && response.data.results && response.data.results.features\n    ? response.data.results.features\n    : []\n\n  let places = formatPlaces(placeResults)\n  //console.log('Got reponse ', response.data)\n\n  const vibesQuery = vibes ? vibes : []\n\n  // TODO: Consider scoring related vibe differently\n  const vibesCombined = vibesQuery\n    .concat(preferredVibes ? preferredVibes : [])\n\n  const newOptions = {\n    ...options,\n    relatedVibes: relatedVibes\n  }\n\n  // TODO: Incorporate personalized vibe score for user\n  let placesScoredAndSorted = shouldSort\n    ? scorePlaces(\n      places,\n      centerPoint,\n      vibesCombined,\n      scoreBy,\n      ordering,\n      options && options.shouldShuffle\n        ? options.shouldShuffle\n        : false,\n      newOptions // Pass any overrides\n    )\n    : places\n\n  const top_categories = getTopCategories(places)\n  const top_tags = getTopTags(places)\n  const top_vibes = getTopVibes(places)\n  const top_locations = getTopLocations(places)\n\n  return {\n    data: placesScoredAndSorted,\n    count: count,\n    top_categories: top_categories,\n    top_locations: top_locations,\n    top_tags: top_tags,\n    top_vibes: top_vibes,\n    loading: false,\n    timedOut: false,\n  }\n}\n\nexport const fetchPlacesFromSearch = async (location) => {\n  const endpoint = 'https://dev.vibemap.com/search_places'\n  const query = ''\n  const params = new URLSearchParams([\n    ['query', query],\n    ['latitude', location.latitude],\n    ['longitude', location.longitude]\n  ])\n\n  const response = await axios.get(`${endpoint}?${params.toString()}`)\n    .catch(function (error) {\n      console.log('axios error ', error.response && error.response.statusText);\n\n      return {\n        data: [],\n        count: 0,\n        query: '?' + query,\n        top_vibes: null,\n        loading: false,\n        timedOut: false,\n      }\n    })\n\n  return response\n}\n\nexport const fetchPlacesFromIds = async (\n  ids = [\n    '740b43a4-3925-4413-9414-fff9d8d16932',\n    'c8262c66-1a83-4d4b-a3e6-8710864ffd1f'\n  ]\n) => {\n  // Param pattern is like this ?ids={id1}__{id2}\n  const endpoint = ApiUrl + '/search/places'\n\n  params = new URLSearchParams([\n    ['ids', ids.join('__')]\n  ])\n\n  const response = await axios.get(`${endpoint}?${params.toString()}`)\n    .catch(function (error) {\n      console.log('axios error ', error.response && error.response.statusText);\n      return {\n        data: [],\n        error: error,\n        count: 0,\n        query: '?' + params,\n        top_vibes: null,\n        loading: false,\n        timedOut: false,\n      }\n    })\n\n  const count = response.data.count\n  const placeResults = response.data && response.data.results && response.data.results.features\n    ? response.data.results.features\n    : []\n\n  return {\n    data: placeResults,\n    count: count,\n    loading: false,\n    timedOut: false,\n  }\n}\n\n\n// Fetch Places from Elastic Search by slugs\nexport const fetchPlacesFromSlugs = async (slugs = ['salesforce-park']) => {\n  // Param pattern is like this ?ids={id1}__{id2}\n  const endpoint = ApiUrl + '/search/places'\n\n  params = new URLSearchParams([\n    ['slugs', slugs.join('__')]\n  ])\n\n  const response = await axios.get(`${endpoint}?${params.toString()}`)\n    .catch(function (error) {\n      console.log('axios error ', error.response && error.response.statusText);\n      return {\n        data: [],\n        error: error,\n        count: 0,\n        query: '?' + params,\n        top_vibes: null,\n        loading: false,\n        timedOut: false,\n      }\n    })\n\n  const count = response.data.count\n  const placeResults = response.data && response.data.results && response.data.results.features\n    ? response.data.results.features\n    : []\n\n  return {\n    data: placeResults,\n    count: count,\n    loading: false,\n    timedOut: false,\n  }\n}\n\n// Handle fields from the tile server\nexport const decodePlaces = (places) => {\n  const decoded = places.map((feature) => {\n    //console.log('feature: ', feature)\n    feature.properties.vibes = JSON.parse(feature.properties.vibes)\n    feature.properties.subcategories = JSON.parse(\n      feature.properties.subcategories\n    )\n    feature.properties.categories = JSON.parse(feature.properties.categories)\n    feature.properties.vibemap_images = []\n    feature.properties.images = [feature.properties.thumbnail_url]\n    if (feature.properties.opening_hours != undefined)\n      feature.properties.opening_hours = JSON.parse(\n        feature.properties.opening_hours\n      )\n    delete feature.properties.tips\n    //delete feature.properties.subcategories\n    delete feature.properties.facebook\n    delete feature.properties.telephone\n    delete feature.properties.website\n\n    return feature\n  })\n\n  return decoded\n}\n\n// Do some post-parsing clean up to the data\n// TODO: API Update for Places\nexport const formatPlaces = (places = []) => {\n  // TODO: Replace with activityCategories\n\n  // FIXME: Make this flat level 1 categories\n  const categories = categories_flat\n  const categories_top_flat = getCategoriesByLevel(2).map(category => category.slug)\n\n  const formatted = places.map((place) => {\n    if (!place) {\n      return null; // Skip null or undefined places\n    }\n    let fields = place.properties\n    // Add fields for presentation\n    fields.place_type = 'places'\n    fields.short_name = truncate(fields.name, constants.TRUCATE_LENGTH)\n    fields.aggregate_rating = parseFloat(fields.aggregate_rating)\n    if (fields.aggregate_rating_count == null) {\n      fields.aggregate_rating_count = 1\n    }\n    fields.num_vibes = fields.vibes.length\n\n    fields.sub_categories = fields.sub_categories\n    fields.top_vibe = null\n\n    const matchingCategories = fields.categories\n      .map(category => {\n        if (category == 'Drink') category = 'Drinking'\n        return category.toLowerCase()\n      })\n      .filter(category => categories_top_flat.includes(category.toLowerCase()))\n\n    const sortedCategories = sortByArray(matchingCategories, categories)\n\n    if (fields.categories === undefined ||\n      fields.categories.length === 0) {\n      fields.categories = ['place']\n    }\n\n    // TODO: Add proper theming\n    const theme = 'light'\n    const icon_label = sortedCategories[0] ? sortedCategories[0] : 'dot'\n    fields.icon = sortedCategories[0] ? `icon_${icon_label}_${theme}` : icon_label\n    fields.cluster = null\n\n    place.properties = fields\n    return place\n  }).filter(Boolean);\n  return formatted\n}\n\nexport const vibesFromPlaces = (places) => {\n  const vibes = []\n  // TODO: get frequency of vibes from a set of places\n  return vibes\n}\n\nexport const getRecommendedVibes = (vibes) => {\n  const recommended = []\n  // Find related and recommended vibes for the given set.\n  return recommended\n}\n\nexport const scorePlaces = (\n  places,\n  centerPoint,\n  vibes = [],\n  scoreBy = ['vibes', 'aggregate_rating', 'distance'],\n  ordering,\n  shuffle = true,\n  zoom = 12,\n  options = {}\n) => {\n  //console.log('scorePlaces: ', places, ordering, scoreBy)\n\n  // Default max values; These will get set by the max in each field\n  let maxScores = {}\n\n  // Bonuses between 1 and 10\n  // TODO reconfigure bonus scores in a way that is more mathematically sound\n  // to use zoom-weight scaling\n\n  const vibeMatchBonus = 10\n  const vibeRelatedBonus = 2\n  const vibeOrderBonus = 1\n  const vibeAmountBonus = 2\n  const offerBonus = 2\n  const imageBonus = 2\n  const openBonus = 0.5\n  const popularBonus = 5\n\n  // TODO: If ordered by vibe, rank matches very high\n  const vibeRankBonus = ordering == 'vibe' ? 30 : 20\n\n  // ⚡ \tFirst, initialize the scoring fields\n  //\t\tDefaults should be on extreme ends to prevent logical errors\n  let minScores = {};\n\n  scoreBy.map((field) => (maxScores[field] = 0.00001))\n  // Default min values; These will get set by the min in each field\n  scoreBy.map((field) => (minScores[field] = Infinity))\n\n  // Default any zoom level less than ten to be ten, not useful to weigh distance at that point\n  let zoom_to_use = zoom <= 10 ? 10 : zoom;\n  let zoom_norm = normalize_all(zoom_to_use, 10, 20, 0, 10)\n\n  // Logistic growth equation. Max weight is 8, minimum of 1. Weight grows exponentially in the middle range\n  // TODO: pull this out into own function, allows us to weigh distance differently depending on zoom\n  let zoom_weight = 8 / (1 + (7 * (Math.exp(1) ** (-0.7 * zoom_norm))))\n\n  // Weight distance & rating different than other fields\n  // TODO: Make everything a consitent 1-10 scale\n  let weights = {\n    category: 0,\n    vibe: 10,\n    distance: zoom_weight,\n    rating: 4,\n    hours: 0,\n    offers: 0,\n  }\n\n  // If there are vibes, weigh the strongest by 3x\n  // if (vibes.length > 0 && ordering === 'relevance') weights.vibe = 2\n  // Do the same for other sorting preferences\n  if (ordering !== 'relevance') weights[ordering] += 3\n\n  // Get scores and max in each category\n  const placesScored = places.map((place) => {\n    let fields = place.properties\n    fields.stats = {}\n\n    // Give place a vibe score\n    // TODO: Calculate `vibe_score` on backend with stored procedure.\n    // TODO: Make a separate, modular method\n    if (scoreBy.includes('vibes')) {\n      let [vibeMatches, relatedVibeMatches, averageRank, vibeBonus] = [0, 0, 0, 0]\n\n      fields.vibes_score = 0\n      // TODO: TEMP until events return vibes\n      if (fields.vibes === undefined) fields.vibes = ['chill']\n\n      // Based off logrithmic scale, a place with 20 vibes isn't that much (twice) better than one with 10\n      const scoreVibeLength = fields.vibes.length > 0\n        ? vibeAmountBonus * Math.log10(fields.vibes.length)\n        : 0\n\n      if (fields.vibes.length > 0) fields.vibes_score = scoreVibeLength\n\n      // Don't show markers without photos; this will analyze the vibe and quality of the image\n      //Reward photos logrithmically as well. Log indicates scaling behavior, coefficient the weight\n      if (fields.images && fields.images.length > 0) vibeBonus += fields.images.length > 0\n        ? imageBonus * Math.log10(fields.images.length)\n        : 0\n\n      // Give direct vibe matches bonus points\n      if (vibes && vibes.length > 0 && fields.vibes) {\n        vibeMatches = matchLists(vibes, fields.vibes)\n\n        relatedVibeMatches = options.relatedVibes ?\n          matchLists(options.relatedVibes, fields.vibes)\n          : 0\n        // The average rank scores by the order of the array\n        // That is the first vibe gets ranks higher than the last one\n        averageRank = rankVibes(vibes, fields.vibes)\n\n        // Bonus for exact matches + all place vibes\n        const vibeMatchScore = vibeMatches * vibeMatchBonus + relatedVibeMatches * vibeRelatedBonus\n        const vibeOrderScore = averageRank * vibeOrderBonus\n        vibeBonus += vibeMatchScore + vibeOrderScore\n        fields.vibes_score += vibeBonus\n\n        // For debugging purposes\n        fields.stats['num_vibes'] = fields.vibes.length\n        fields.stats['num_matching_vibes'] = vibeMatches\n        fields.stats['vibe_match_score'] = vibeMatchScore\n        fields.stats['vibe_order_score'] = vibeOrderScore\n      }\n\n      // Set max vibe score\n      if (fields.vibes_score > maxScores.vibes) {\n        maxScores.vibes = fields.vibes_score\n      }\n\n      if (fields.vibes_score < minScores.vibes) {\n        minScores.vibes = fields.vibes_score\n      }\n\n      //console.log('Scoring weights: ', weights, ordering, vibeRankBonus)\n      //console.log('For these vibes: ', fields.vibes)\n      //console.log('Vibe score bonus: ', fields.vibes_score, vibeBonus)\n      //console.log('Vibe order bonus: ', fields.vibes_score, vibeBonus)\n      //console.log('Vibe score: ', vibeMatches, averageRank, vibeBonus)\n      fields.stats['total_vibe_score'] = fields.vibes_score\n    }\n\n    // Get scores and max in each category\n    // TODO: Make a separate, modular method\n    if (scoreBy.includes('categories')) {\n      let [categoryMatches, averageRank, vibeBonus] = [0, 0, 0]\n\n      fields.categories_score = 0\n\n      // Merge and remove duplicates\n      const concatCategories = fields.categories.concat(fields.subcategories);\n      const allCategories = concatCategories.filter(\n        (item, index) => concatCategories.indexOf(item) == index\n      );\n\n      if (fields.categories.length > 0)\n        fields.categories_score = fields.categories.length\n      //console.log('Base category score: ', fields.categories_score, allCategories)\n\n      // Give matching categories for the vibe a bonus\n      if (vibes.length > 0) {\n        // Get vibes for the place category\n        let categoryVibes = []\n        allCategories.forEach((category) => {\n          //console.log('Category: ', fields.name, category)\n          // TODO: There probably a cleaner way to search for both categories and subcategories\n          const foundCategories = constants.place_sub_categories.filter((o) =>\n            o.main_category.includes(category)\n          );\n          const foundSubcategories = constants.place_sub_categories.filter(\n            (o) => o.name.includes(category)\n          );\n\n          if (foundCategories.length > 0) {\n            categoryVibes = categoryVibes.concat(foundCategories[0].vibes);\n          }\n\n          if (foundSubcategories.length > 0) {\n            categoryVibes = categoryVibes.concat(foundSubcategories[0].vibes);\n          }\n        });\n\n        categoryMatches = matchLists(vibes, categoryVibes)\n        const bonus = categoryMatches * vibeMatchBonus\n        fields.categories_score += bonus\n      }\n\n      if (fields.categories_score > maxScores['categories']) {\n        maxScores['categories'] = fields.categories_score;\n      }\n      if (fields.categories_score < minScores['categories']) {\n        minScores['categories'] = fields.categories_score;\n      }\n    }\n\n    // Get the min and max scores for normalization\n    // Add score for the number of likes or RSVPs for events\n    if (scoreBy.includes('likes')) {\n      // Set max aggregate score\n      if (fields.likes > maxScores['likes']) {\n        maxScores['likes'] = fields.likes\n      }\n\n      if (fields.likes < minScores['likes']) {\n        minScores['likes'] = fields.likes\n      }\n    }\n\n    // Add score for distance from user\n    if (scoreBy.includes('distance')) {\n      // TODO: Make a util in map.js\n      const placePoint = turf.point(place.geometry ? place.geometry.coordinates : [0, 0])\n\n      // Does this return in kilometers? Miles?\n      fields['distance'] = turf_distance(centerPoint, placePoint)\n      // Set max distance\n      if (fields['distance'] > maxScores['distance']) {\n        maxScores['distance'] = fields['distance']\n      }\n      if (fields['distance'] < minScores['distance']) {\n        minScores['distance'] = fields['distance']\n      }\n    }\n\n    if (scoreBy.includes('aggregate_rating')) {\n      // Set max aggregate score\n      if (fields.aggregate_rating > maxScores['aggregate_rating']) {\n        maxScores['aggregate_rating'] = fields.aggregate_rating\n      }\n      if (fields.aggregate_rating < minScores['aggregate_rating']) {\n        minScores['aggregate_rating'] = fields.aggregate_rating\n      }\n\n      if (minScores['aggregate_rating_count'] == undefined) {\n        minScores['aggregate_rating_count'] = 1\n        maxScores['aggregate_rating_count'] = 1\n      }\n      // And the count of ratings that make the score\n      if (fields.aggregate_rating_count > maxScores['aggregate_rating_count']) {\n        maxScores['aggregate_rating_count'] = fields.aggregate_rating_count\n      }\n      if (fields.aggregate_rating_count < minScores['aggregate_rating_count']) {\n        minScores['aggregate_rating_count'] = fields.aggregate_rating_count\n      }\n    }\n\n    // TODO: WIP concept for popular times and hours\n    // TODO: Move to backend or make a separate, modular method\n    //console.log('Score place on these fields: ', fields.offers, fields.opening_hours)\n    fields.offers_score = 0\n    fields.hours_score = 0\n\n    // Give bonus if place has offers or is open\n    if (scoreBy.includes('offers')) {\n      if (fields.offers && fields.offers.length > 0) {\n        fields.offers_score = offerBonus\n      }\n\n      let { openNow, openToday, opens, closes, isPopular } = isOpen(\n        fields.opening_hours\n      );\n\n      // Store in place details\n      // TODO: Make sure these field name match the upgraded API\n      fields.open_now = openNow\n      fields.popular_now = isPopular\n      fields.opens = opens\n      fields.closes = closes\n\n      // Give bonus if open now\n      if (openToday) fields.hours_score += openBonus\n      if (openNow) fields.hours_score += openBonus\n      if (isPopular) fields.hours_score += popularBonus\n    }\n\n    fields.stats['hours_bonus'] = fields.hours_score\n\n    place.properties = fields\n    return place\n  });\n\n  // Now normalize all the scores\n  let maxAverageScore = 0\n  let minAverageScore = Infinity\n\n  // Normalize each place by the top scores across all results\n  let placesScoredAveraged = placesScored.map((place) => {\n    let fields = place.properties\n\n    // TODO: This could be more steamlined automatically for each key in scoreBy\n    if (scoreBy.includes('vibes')) {\n      fields.vibes_score = normalize_all(fields.vibes_score, minScores['vibes'], maxScores['vibes'], 0, 1)\n      fields.vibes_score = fields.vibes_score * weights['vibe']\n      //console.log('fields.vibes_score: ', fields.name, fields.vibes_score)\n    }\n\n    if (scoreBy.includes('categories')) {\n      fields.categories_score = normalize_all(\n        fields.categories_score, minScores['categories'], maxScores['categories'], 0, 1);\n      fields.categories_score = fields.categories_score * weights['category']\n      //console.log('fields.categories_score: ', fields.name, fields.categories_score)\n    }\n\n    if (scoreBy.includes('likes')) {\n      fields.likes_score = normalize_all(fields.likes, minScores['likes'], maxScores['likes'], 0, 1)\n    }\n\n    if (scoreBy.includes('venue')) {\n      fields.venue_score = normalize_all(fields.place_vibe_count, minScores['likplace_vibe_countes'], maxScores['place_vibe_count'], 0, 1)\n    }\n\n    // Get average rating and scale it by a factor\n    if (scoreBy.includes('aggregate_rating')) {\n      const aggregate_score = normalize_all(\n        fields.aggregate_rating,\n        minScores['aggregate_rating'],\n        maxScores['aggregate_rating'],\n        0, 1)\n\n      const aggregate_rating_count_score = normalize_all(\n        fields.aggregate_rating_count,\n        minScores['aggregate_rating_count'],\n        maxScores['aggregate_rating_count'],\n        0, 1)\n\n      //console.log('DEBUG: Combine rating score ', aggregate_score, aggregate_rating_count_score)\n      fields.aggregate_rating_score = (aggregate_score + aggregate_rating_count_score) / 2\n      fields.aggregate_rating_score *= weights.rating\n      fields.stats['aggregate_rating_score'] = fields.aggregate_rating_score\n    }\n\n    // Smallest distance gets largest score\n    if (scoreBy.includes('distance')) {\n      let maxDistance = maxScores['distance']\n\n      /* all distance values are normalized between 0 and 0.95. Since we take the difference of 1 and the score,\n        the lowest possible distance_score is 0.05, and the highest is 1. We do this such that lower distances\n        (closer places) get a higher distacne score.\n      */\n      fields.distance_score = 1 - normalize_all(fields.distance, minScores['distance'], maxDistance, 0, 0.95)\n\n      //console.log(fields.distance, minScores['distance'], maxDistance, maxDistance - fields.distance, fields.distance_score)\n      fields.distance_score *= weights.distance\n      fields.stats['distance_score'] = fields.distance_score\n    }\n\n    if (scoreBy.includes('hours')) {\n      fields.hours_score *= weights.hours\n    }\n\n    const reasons = scoreBy;\n    const scores = scoreBy.map((field) => fields[field + '_score'])\n\n    // Find the larged score\n    const largestIndex = scores.indexOf(Math.max.apply(null, scores))\n\n    // Find the smallest score\n\n    scores.indexOf(Math.min.apply(null, scores))\n\n    // Take an average of each of the scores\n    fields.average_score = scores.reduce((a, b) => a + b, 0) / scores.length\n    // Update the top average score\n    if (fields.average_score > maxAverageScore)\n      maxAverageScore = fields.average_score;\n\n    if (fields.average_score < minAverageScore)\n      minAverageScore = fields.average_score\n    // Add the update the reason code\n    fields.reason = reasons[largestIndex]\n    //console.log(`Top reason `, fields.name, fields.reason)\n\n    place.properties = fields\n    return place\n  })\n\n  // Re-sort by average score\n  const placesScoredAndSorted = placesScoredAveraged.sort(\n    (a, b) => b.properties.average_score - a.properties.average_score\n  )\n\n  // Normalize the scores between 0.65 and 1\n  const placesSortedAndNormalized = placesScoredAndSorted.map((place) => {\n    let fields = place.properties\n    //console.log(place.properties.name, minAverageScore, fields.average_score, maxAverageScore)\n\n    // ⚡⚡ final score returned to user is normalized between 0.65 and 1\n    fields.average_score = normalize_all(fields.average_score, minAverageScore, maxAverageScore, 0.65, 1)\n    fields.icon_size = scaleIconSize(fields.average_score, 0.65, 1)\n\n    // All average_scores should be between 0.65 and 1, and icon_size between 1 and 5. Should also print in descending order\n    //If so, then all is working well\n    //console.log(place.properties.name, place.properties.address, fields.average_score, fields.distance_score, weights.distance)//, fields.icon_size)\n    // Scale the icon size based on score\n    fields.stats['final_score_normalized'] = fields.average_score\n\n    return place\n  })\n\n  // TODO: for debugging only\n  /*placesSortedAndNormalized.map((place) => {\n    console.log(place.properties.name)\n    console.log(' - score: ', place.properties.average_score)\n    console.log(' - vibes_score: ', place.properties.vibes_score)\n    console.log(' - aggregate rating: ', place.properties.aggregate_rating_score)\n    console.log(' - distance: ', place.properties.distance_score, \"weight: \", weights.distance)\n    console.log(' - reason: ', place.properties.reason)\n    console.log(' - final_score_normalized: ', place.properties.average_score)\n  })\n  */\n\n  const numPlaces = placesSortedAndNormalized.length\n  const results = shuffle && numPlaces > 100\n    ? module.exports.shuffleTopPicks(placesSortedAndNormalized)\n    : placesSortedAndNormalized\n\n  return results\n}\n\n// Only return the requested fields and remove all others from GeoJSON properies\nexport const reducePlaceProperties = (\n  places,\n  fields = [\n    'name',\n    'url',\n    'address',\n    'categories',\n    'subcategories',\n    'neighborhood',\n    'price',\n    'short_description',\n    'vibemap_images',\n    'vibes'\n  ]) => {\n\n  const places_reduced = places.map(place => {\n    place.properties = Object.fromEntries(\n      fields.map(key => [key, place.properties[key]])\n    )\n    return place\n    //console.log('reduced this place ', place.properties)\n  })\n\n  return places_reduced\n}\n\nexport const shuffleTopPicks = (places, numTop = 20) => {\n  // Slice and Shuffle\n  const topPlaces = places.slice(0, numTop)\n    .map(value => ({ value, sort: Math.random() }))\n    .sort((a, b) => a.sort - b.sort)\n    .map(({ value }) => value)\n\n  // Store remainder\n  const remainingPlaces = places.slice(numTop)\n\n  // Combine and return all\n  const placesCombined = topPlaces.concat(remainingPlaces)\n  return placesCombined\n}\n\nexport const toTitleCase = (str) => {\n  if (typeof str == 'string') {\n    str = str.toLowerCase().split(' ')\n    for (var i = 0; i < str.length; i++) {\n      str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1)\n    }\n    return str.join(' ')\n  } else {\n    return str\n  }\n}\n\n\n// TODO: add neighborhood as top place of the list. Will need some neighborhood cards\n//Function that returns every place within a certain specified radius\nexport const nearest_places = (places, currentLocation, radius = 5) => {\n  //console.log(\"current Location: \", currentLocation)\n  //console.log(\"Full list of Places: \", places)\n\n  // Push any place whose distance is under radius (0.1) to places_temp\n  var places_temp = []\n  const distance_calculated = places.map((place) => {\n    let fields = place.properties\n    const placePoint = turf.point(place.geometry.coordinates)\n    fields['distance'] = turf_distance(currentLocation, placePoint)\n    if (fields['distance'] < radius) {\n      places_temp.push(place)\n      //console.log(\"Place within bound: \", fields[\"distance\"])\n    }\n  })\n\n  // Sort on a copy not a reference\n  var places_to_return = places_temp.slice(0)\n\n  // Do sorting after .map(), should be faster performance\n  places_to_return.sort(function (a, b) {\n    return a.properties.distance - b.properties.distance\n  })\n\n  /* For debugging, make sure every place is sorted in ascending order\n  places_to_return.map((x) => {\n    console.log(\"sorted: \", x.properties.distance)\n  })\n  */\n  return places_to_return\n}\n\n//Function that checks if a place is within a certain distance of user, for check ins\nexport const validate_check_in = (place, currentLocation, threshold = 0.5) => {\n  const placePoint = turf.point(place.geometry.coordinates)\n  const within_distance = turf_distance(currentLocation, placePoint) < threshold ? true : false\n  return within_distance\n}\n// Function determines if a point falls into the specific boundaries of Jack London District\nexport const in_jls = (currentLocation) => {\n\n  // Hand drawn locations. Roughly everything beneath 7th St, between Market St. and Fallon St.\n  const bounds_jls = turf.polygon([[\n    [-122.282617, 37.802862],\n    [-122.264300, 37.795721],\n    [-122.265502, 37.787005],\n    [-122.288139, 37.796077],\n    [-122.282617, 37.802862]\n  ]])\n  return turf_boolean(currentLocation, bounds_jls)\n}\n\n// Primary function that returns a list of neighborhoods the location is in.\n// The input is the place's properties, returns array of neighborhood id's\n// Vectorizes our wordpress neighborhoods data (neighborhoods.json) and flexibly utilizes available information as bounds\n// If no bounds (bbox) is given, use radius, if no radius, then a hard radius of 0.8 km is set\nexport const in_neighborhood = (place) => {\n\n  // Name array is not returned but could be if desired, more for debugging\n  const valid_neighborhoods_id = []\n  const valid_neighborhoods_name = []\n  const turf_point = turf.point(place.geometry.coordinates)\n\n  neighborhoods.map((neighborhood) => {\n    const neigh_dist = turf_distance([neighborhood.map.lng, neighborhood.map.lat], turf_point)\n\n    /* Use helper function since can't assign turf.boolean() to non valid polygons which in turn can't be handled within\n     the conditional statement*/\n    if (neigh_dist < 5 && in_bbox_helper(place.geometry.coordinates, neighborhood.boundary)) {\n      valid_neighborhoods_id.push(neighborhood.id)\n      valid_neighborhoods_name.push(neighborhood.slug)\n    } else if (neighborhood.radius > 0.00001 && neigh_dist < neighborhood.radius) {\n      //console.log(\"radius checked\")\n      valid_neighborhoods_id.push(neighborhood.id)\n      valid_neighborhoods_name.push(neighborhood.slug)\n    } else if (neigh_dist < 0.8) {\n      //console.log(\"dist checked\")\n      valid_neighborhoods_id.push(neighborhood.id)\n      valid_neighborhoods_name.push(neighborhood.slug)\n    } else {\n\n    }\n  })\n  return valid_neighborhoods_id\n}\n\n// Helper function to determine if a location is within certain bounds\nexport const in_bbox_helper = (point, bbox) => {\n  if (bbox !== \"\" && bbox !== undefined) {\n    const parsed_bbox = JSON.parse(bbox)\n    const bounds = turf.polygon([parsed_bbox])\n    //console.log(\"bbox\", parsed_bbox)\n    return turf_boolean(point, bounds)\n  } else {\n    //console.log(\"no bbox\")\n    return false\n  }\n}\n\n// General function to find nearest neighborhood of a locations. Returns top ten options\n// Input must be [longitude, lattitude] coordinates\nexport const nearest_neighborhood = (placePoint) => {\n  const neighborhoods_ordered = neighborhoods.map((neighborhood) => {\n    return {\n      name: neighborhood.name,\n      neigh_dist: turf_distance([neighborhood.map.lng, neighborhood.map.lat], placePoint)\n    }\n  })\n  neighborhoods_ordered.sort(function (a, b) {\n    return a.neigh_dist - b.neigh_dist\n  })\n  return neighborhoods_ordered.slice(0, 10)\n}\n\n// Helper function for associate_badge. Returns every neighborhood challenge badge\n// TODO modify such that inputs can be multiple badge types, for example lookup general badges or neighborhood or place etc.\nexport const challenge_badges_lookup = () => {\n  const challenge_badges = []\n  badges.badges.map((badge) => {\n    if (badge.type == \"neighborhood\") {\n      challenge_badges.push(badge)\n    }\n  })\n  return challenge_badges\n}\n\n// Returns array of valid badges (and properties) that a place is associated with. Give points towards that badge\nexport const associate_badge = (locations) => {\n  const badges_to_check = challenge_badges_lookup()\n  const win_badges = []\n  badges_to_check.map((badge) => {\n    console.log(badge)\n    for (let i = 0; i < locations.length; i++) {\n      if (badge.location.ID == locations[i]) {\n        win_badges.push(badge)\n      }\n    }\n  })\n  return win_badges\n}\n\n/**\n * Cities from Mapbox by keyword or name\n *\n * @param {String} search\n *\n * @returns {Object[]}\n */\nexport const searchCities = async (search = '') => {\n  const endpoint = `https://dev.vibemap.com/search_locations/?city=${search}`\n  const distanceForMatch = 10\n  const response = await axios.get(endpoint).catch(error => {\n    console.log(`error `, error)\n    return {\n      error: true,\n      data: error\n    }\n  })\n\n  const results = response.data.map(newCity => {\n\n    const foundCity = cities.find(city => city.name.includes(newCity.name))\n    if (foundCity) {\n      const checkDistance = distanceBetweenLocations(newCity.location, foundCity.location)\n      if (checkDistance < distanceForMatch) {\n        return foundCity\n      }\n    }\n    // TODO: Make this fuzzy search on a new service\n    let foundNeighborhood = neighborhoods.find(neighborhood => {\n      return neighborhood.name.toLowerCase().includes(newCity.name.toLowerCase())\n    })\n\n    return newCity\n  })\n\n  return results\n}\n\n\nexport const searchTags = async (search = 'art') => {\n  // https://api.vibemap.com/v0.3/tag-autocomplete/?q={search}\n  const path = 'tags'\n  const endpoint = `${ApiUrl}/${path}/?${search}`\n  const response = await axios.get(endpoint).catch(error => {\n    console.log(`error `, error)\n    return {\n      error: true,\n      data: error\n    }\n  })\n\n  return response.data\n}\n\nexport const getAllBoundaries = async (admin_level = 'both') => {\n  const random = Math.random()\n  const endpoint = `https://api.vibemap.com/v0.3/boundaries/?admin_level=${admin_level}&include_hidden=1&per_page=1000&random=${random}`\n  // console.log('DEBUG: getAllBoundaries endpoint ', endpoint);\n  const response = await axios.get(endpoint).catch(error => {\n    console.log(`error `, error)\n    return {\n      error: true,\n      data: []\n    }\n  })\n\n  return response.data\n}\n\nexport const getBoundary = async (slug = 'chicago', cache_bust = true) => {\n  const random = Math.random()\n  const endpoint = `https://api.vibemap.com/v0.3/boundaries/?admin_level=both&slug=${slug}${cache_bust ? `&refresh=${random}` : ''}`\n  const response = await axios.get(endpoint).catch(error => {\n    console.log(`error `, error)\n  })\n\n  if (response && response.data) {\n    try {\n      const boundary = response.data.results[0] || null\n      return boundary\n    } catch (error) {\n      console.log('Problem with boundary data ', error);\n      return null\n    }\n\n  } else {\n    return null\n  }\n}\n\nexport const searchPlacesByName = async (options, apiURL) => {\n  //const centerPoint = options.point ? options.point.split(',').map(parseFloat) : ''\n  //console.log('centerPoint ', centerPoint);\n  let apiResult\n\n  // TODO: set ordering by name relevance\n  const params = getAPIParams(options)\n\n  const useElastic = true\n  const apiPath = useElastic ? 'search/places' : 'places'\n\n  const searchQuery = new URLSearchParams(params).toString()\n  const endpoint = `${apiURL}/${apiPath}/?${searchQuery}`\n  //console.log('Search endpoint ', endpoint);\n  apiResult = await axios.get(endpoint)\n    .catch(function (error) {\n      console.log('axios error ', error.response && error.response.statusText);\n\n      return []\n    })\n\n  const results = apiResult.data\n    ? apiResult.data.results.features\n    : []\n  return results\n}\n\n\n/* Simple consumption of our elastic search suggestion endpoint.\n   'string' is user inputted text.\n   If context is true, can set a numerical lat, long, and radius as well.\n   Will suggest places by string input within that boundary\n*/\nexport const suggestPlacesByName = async (\n  string,\n  apiURL = ApiUrl,\n  context = false,\n  latitude = null,\n  longitude = null,\n  radius = null,\n  type = 'places'\n) => {\n\n  // If latitude and longitude, but radius is null, will just return all results in order from closest to furthest\n  let geoContext = latitude !== null & longitude !== null & context\n    ? `${latitude.toString()}__${longitude.toString()}`\n    : null\n\n  // Radius in kilometers\n  geoContext = radius & context\n    ? geoContext + `__${radius.toString()}km`\n    : geoContext\n\n  // context defaulted to false,\n  // targets name_suggest__completion endpoint. Pass true to use geo context filters\n  const fullURL = context\n    ? `${apiURL}/search/${type}/suggest/?name_suggest_context=${string}&name_suggest_loc=${geoContext}`\n    : `${apiURL}/search/${type}/suggest/?name_suggest__completion=${string}`\n  console.log(`DEBUG HELPERS: suggestPlacesByName full URL: ${fullURL}`)\n\n  let apiResult\n  // const searchQuery = new URLSearchParams(searchParams).toString()\n  apiResult = await axios.get(fullURL)\n    .catch(function (error) {\n      console.log('axios error ', error.response && error.response.statusText);\n      return []\n    })\n\n  console.log(\"HELPERS suggestPlacesByName results: \", apiResult.data)\n  // Trimming is slightly different depending on completion or context.\n  const results = apiResult.data\n    ? context\n      ? apiResult.data.name_suggest_context[0].options.map((item) => {\n        return item[\"_source\"]\n      })\n      : apiResult.data.name_suggest__completion[0].options.map((item) => {\n        return item[\"_source\"]\n      })\n    : []\n  return results\n}\n\n\n/**\n * Gets related vibes for a neighborhood and sorts neighborhoods\n * by vibe intersection count between related and neighborhood vibes.\n *\n * @param {Object[]} neighborhoods\n * @param {String[]} vibeSlugs\n *\n * @returns {Object[]}\n */\nexport const sortNeighborhoodsByVibes = (neighborhoods, vibeSlugs) => {\n  if (vibeSlugs.length === 0) return neighborhoods\n\n  const relatedVibeSlugs = getRelatedVibes(vibeSlugs)\n  const vibeSlugsToIntersect = [...new Set([...vibeSlugs, ...relatedVibeSlugs])]\n\n  // add vibeIntersection property\n  const neighborhoodsWithVibeIntersection = neighborhoods.map(\n    (neighborhood) => {\n      const neighborhoodVibes = neighborhood.vibes || neighborhood.acf.vibes\n      const neighborhoodVibeSlugs = neighborhoodVibes.map(({ slug }) => slug)\n\n      const vibeIntersection = vibeSlugsToIntersect.filter((slug) =>\n        neighborhoodVibeSlugs.includes(slug)\n      ).length\n\n      return {\n        ...neighborhood,\n        vibeIntersection\n      }\n    }\n  )\n\n  const sortedNeighborhoods = neighborhoodsWithVibeIntersection.sort((a, b) =>\n    b.vibeIntersection - a.vibeIntersection\n  )\n\n  // remove vibeIntersection property (just to not alter previous structure)\n  return sortedNeighborhoods.map((neighborhood) => {\n    const { vibeIntersection, ...restOfNeighborhood } = neighborhood\n    return restOfNeighborhood\n  })\n}\n\nexport const uploadImageKit = async ({\n  domain = 'https://vibemap.com',\n  file_path = null,\n  fileName = 'image_generic',\n  type = 'base64', // base64, url, file\n  image_data = 'data:image/gif;base64,R0lGODlhPQBEAPeoAJosM//AwO/AwHVYZ/z595kzAP/s7P+goOXMv8+fhw/v739/f+8PD98fH/8mJl+fn/9ZWb8/PzWlwv///6wWGbImAPgTEMImIN9gUFCEm/gDALULDN8PAD6atYdCTX9gUNKlj8wZAKUsAOzZz+UMAOsJAP/Z2ccMDA8PD/95eX5NWvsJCOVNQPtfX/8zM8+QePLl38MGBr8JCP+zs9myn/8GBqwpAP/GxgwJCPny78lzYLgjAJ8vAP9fX/+MjMUcAN8zM/9wcM8ZGcATEL+QePdZWf/29uc/P9cmJu9MTDImIN+/r7+/vz8/P8VNQGNugV8AAF9fX8swMNgTAFlDOICAgPNSUnNWSMQ5MBAQEJE3QPIGAM9AQMqGcG9vb6MhJsEdGM8vLx8fH98AANIWAMuQeL8fABkTEPPQ0OM5OSYdGFl5jo+Pj/+pqcsTE78wMFNGQLYmID4dGPvd3UBAQJmTkP+8vH9QUK+vr8ZWSHpzcJMmILdwcLOGcHRQUHxwcK9PT9DQ0O/v70w5MLypoG8wKOuwsP/g4P/Q0IcwKEswKMl8aJ9fX2xjdOtGRs/Pz+Dg4GImIP8gIH0sKEAwKKmTiKZ8aB/f39Wsl+LFt8dgUE9PT5x5aHBwcP+AgP+WltdgYMyZfyywz78AAAAAAAD///8AAP9mZv///wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACH5BAEAAKgALAAAAAA9AEQAAAj/AFEJHEiwoMGDCBMqXMiwocAbBww4nEhxoYkUpzJGrMixogkfGUNqlNixJEIDB0SqHGmyJSojM1bKZOmyop0gM3Oe2liTISKMOoPy7GnwY9CjIYcSRYm0aVKSLmE6nfq05QycVLPuhDrxBlCtYJUqNAq2bNWEBj6ZXRuyxZyDRtqwnXvkhACDV+euTeJm1Ki7A73qNWtFiF+/gA95Gly2CJLDhwEHMOUAAuOpLYDEgBxZ4GRTlC1fDnpkM+fOqD6DDj1aZpITp0dtGCDhr+fVuCu3zlg49ijaokTZTo27uG7Gjn2P+hI8+PDPERoUB318bWbfAJ5sUNFcuGRTYUqV/3ogfXp1rWlMc6awJjiAAd2fm4ogXjz56aypOoIde4OE5u/F9x199dlXnnGiHZWEYbGpsAEA3QXYnHwEFliKAgswgJ8LPeiUXGwedCAKABACCN+EA1pYIIYaFlcDhytd51sGAJbo3onOpajiihlO92KHGaUXGwWjUBChjSPiWJuOO/LYIm4v1tXfE6J4gCSJEZ7YgRYUNrkji9P55sF/ogxw5ZkSqIDaZBV6aSGYq/lGZplndkckZ98xoICbTcIJGQAZcNmdmUc210hs35nCyJ58fgmIKX5RQGOZowxaZwYA+JaoKQwswGijBV4C6SiTUmpphMspJx9unX4KaimjDv9aaXOEBteBqmuuxgEHoLX6Kqx+yXqqBANsgCtit4FWQAEkrNbpq7HSOmtwag5w57GrmlJBASEU18ADjUYb3ADTinIttsgSB1oJFfA63bduimuqKB1keqwUhoCSK374wbujvOSu4QG6UvxBRydcpKsav++Ca6G8A6Pr1x2kVMyHwsVxUALDq/krnrhPSOzXG1lUTIoffqGR7Goi2MAxbv6O2kEG56I7CSlRsEFKFVyovDJoIRTg7sugNRDGqCJzJgcKE0ywc0ELm6KBCCJo8DIPFeCWNGcyqNFE06ToAfV0HBRgxsvLThHn1oddQMrXj5DyAQgjEHSAJMWZwS3HPxT/QMbabI/iBCliMLEJKX2EEkomBAUCxRi42VDADxyTYDVogV+wSChqmKxEKCDAYFDFj4OmwbY7bDGdBhtrnTQYOigeChUmc1K3QTnAUfEgGFgAWt88hKA6aCRIXhxnQ1yg3BCayK44EWdkUQcBByEQChFXfCB776aQsG0BIlQgQgE8qO26X1h8cEUep8ngRBnOy74E9QgRgEAC8SvOfQkh7FDBDmS43PmGoIiKUUEGkMEC/PJHgxw0xH74yx/3XnaYRJgMB8obxQW6kL9QYEJ0FIFgByfIL7/IQAlvQwEpnAC7DtLNJCKUoO/w45c44GwCXiAFB/OXAATQryUxdN4LfFiwgjCNYg+kYMIEFkCKDs6PKAIJouyGWMS1FSKJOMRB/BoIxYJIUXFUxNwoIkEKPAgCBZSQHQ1A2EWDfDEUVLyADj5AChSIQW6gu10bE/JG2VnCZGfo4R4d0sdQoBAHhPjhIB94v/wRoRKQWGRHgrhGSQJxCS+0pCZbEhAAOw==',\n  tags = ['user_upload']\n}) => {\n  // Payload for imagekit\n  const json = {\n    \"base64\": image_data,\n    \"path\": file_path,\n  }\n\n  // Upload image to imagekit\n  const response = await axios.post(\n    `${domain}/.netlify/functions/upload`,\n    JSON.stringify(json)\n  )\n\n  if (response && response.status == 200 && response.data) {\n    return response.data.image\n  } else {\n    return null\n  }\n}\n\n/** @returns {Promise<{status: \"success\", data: AxiosResponse<any>} | {status: \"error\", error: unknown}> } */\nexport const uploadVibemapImage = async ({\n  hotspots_place_id,\n  id,\n  filename = 'image_generic',\n  title = 'Image from User',\n  size,\n  src,\n  url,\n}) => {\n\n  try {\n    const json = {\n      hotspots_place_id,\n      id,\n      filename,\n      title,\n      size,\n      src,\n      url,\n    }\n\n    const response = await axios.post(\n      `${ApiUrl}images/places/`,\n      json\n    )\n\n    return { status: \"success\", data: response }\n\n  } catch (err) {\n    return { status: \"error\", error: err }\n  }\n}\n\nexport { activityCategories, cities, neighborhoods }"],"names":["axiosRetry","Axios","retries","retryDelay","exponentialDelay","onRetry","count","err","config","console","log","axios","jsonpack","dayjs","extend","isBetween","dayjsRecur","require","activityCategories","let","categories_flat","cities","neighborhoods","getAPIDomain","mode","env_mode","process","env","API_ENV","current_mode","api_domain","api_version","useSearchAPI","useSearchAPIEvents","ApiUrl","filterList","list","test","value","searchTerm","key","literal","results","filter","item","re","RegExp","replace","result","isMatch","getRandomItem","Math","floor","random","length","encodeCardIndex","row","column","matchLists","listA","listB","matches","includes","word","rankVibes","rankings","map","score","indexOf","reduce","a","b","sortByKey","sortByPopularity","aPop","parseInt","details","msv","activityCategoriesPacked","unpack","sort","category","name","toLowerCase","error","citiesPacked","neighborhoodsPacked","sortByArray","sortedList","sortingArr","isClosedToday","dailyHours","opens","closes","displayHours","hours","dayFormat","openHours","isOpen","weeklyHours","find","day_of_week","openEveryday","times","time","format","popularFound","push","day","i","orderedHours","dayFound","hasDailyHours","undefined","isClosed","closed","Object","assign","dayHours","formatDailyHours","includeDay","split","has_minutes","dayText","hourFormat","hourText","hour","minute","minutesText","hoursForDay","hoursText","nextHours","nextText","date","openNow","openToday","isPopular","daysClosed","parseDateTime","datetime","formatDateTime","formatHtml","showDayOfWeek","month","weekday","getCardOptions","categoryQuery","distanceQuery","geoQuery","searchQuery","vibeQuery","block","singCards","posts","overrideQuery","vibe","selectedCity","slug","location","distance","firstCity","vibesFromCategories","point","longitude","latitude","ordering","search","vibes","getAPIParams","options","includeRelated","useElastic","activity","bounds","per_page","tags","params","distanceInMeters","round","constants.METERS_PER_MILE","coords","lat","lon","hasCoords","bounds_query","reverse","join","start_date","start_date_after","date_time","date_start","startOf","end_date","end_date_before","date_end","endOf","editorial_category","term","Date","now","is_approved","is_chain","is_closed","is_destination","city","getCategoryMatch","categories","all_categories","getFullLink","link","type","parse_url","url","parse","URL","path","instagram","twitter","facebook","geLocationFromCity","cityDetails","placemarker","getMax","items","attribute","max","forEach","getMin","min","getTimeOfDay","isValid","currentHour","parseFloat","getTopLocations","places","location_type","flat","top_locations","place","properties","hasOwnProperty","sortable","top_locations_sorted","getTopTags","top_tags","tag","top_tags_sorted","getTopVibes","top_vibes","top_vibes_sorted","getTopCategories","top_categories","getWaveFromVibe","graphToEvents","edges","edge","groupEvent","node","groupDetails","description","image","images","original","price","recurrence","recurring","which","startTime","endTime","recurRule","nextDateFromRecurring","nextStartTime","next","toLocaleString","nextEndTime","id","title","geometry","coordinates","dateTime","card_type","address","streetAddress","is_online","hotspots_place","vibemap_images","likes","recurs","groupsToEvents","groups","acf","label","start_time","end_time","toISOString","normalize","val","normalize_all","scale_low","scale_high","scale","LinearScale","domain","range","scaleIconSize","scaleMarker","zoom","isNaN","marker_scale","base_marker","max_marker","scaleDensityArea","density","area","density_scale","scaleDensityBonus","inverted_scale","constants.HEATMAP_INTENSITY","HEATMAP_INTENSITY","relative_density","scaleScore","scaleSelectedMarker","isDateFormatYYYYMMDD","str","getDatesFromRange","date_range","start_date_formated","start_with_year","start_date_slashes","today","dayOfWeek","startOffset","endOffset","monthEnd","diff","start","add","end","getEventOptions","start_date_custom","end_date_custom","page","locations","concat","selectedLocation","has_dashes","end_date_formated","startAndEnd","date_range_start","date_range_end","fetchEvents","async","activitySearch","recurringSearch","days","centerPoint","currentLocation","getLocationFromPoint","nearestCities","sortLocations","module","exports","query","querystring","stringify","apiEndpoint","source","CancelToken","response","get","cancelToken","token","catch","statusText","data","loading","timedOut","getGroups","recurringGroupEvents","features","events","whichDay","weekOfMonth","recur","every","daysOfWeek","weeksOfMonthByDay","fetchPlacesDetails","fetchPlacePicks","preferredVibes","relatedVibes","shouldSort","useNearest","numOfPlaces","hasVibes","distanceFrom","distanceBetweenLocations","centerpoint","getPlaces","newOptions","placeResults","formatPlaces","vibesQuery","vibesCombined","placesScoredAndSorted","scorePlaces","shouldShuffle","fetchPlacesFromSearch","URLSearchParams","toString","fetchPlacesFromIds","ids","endpoint","fetchPlacesFromSlugs","slugs","decodePlaces","feature","JSON","subcategories","thumbnail_url","opening_hours","tips","telephone","website","categories_top_flat","getCategoriesByLevel","fields","place_type","short_name","truncate","constants.TRUCATE_LENGTH","aggregate_rating","aggregate_rating_count","num_vibes","sub_categories","top_vibe","matchingCategories","sortedCategories","icon_label","icon","cluster","Boolean","vibesFromPlaces","getRecommendedVibes","scoreBy","shuffle","maxScores","minScores","field","Infinity","zoom_to_use","zoom_norm","weights","exp","rating","offers","placesScored","stats","vibeMatches","vibeBonus","vibes_score","scoreVibeLength","log10","vibeMatchScore","vibeOrderScore","categoryMatches","categories_score","concatCategories","allCategories","index","categoryVibes","foundCategories","constants.place_sub_categories","o","main_category","foundSubcategories","placePoint","turf","turf_distance","offers_score","hours_score","open_now","popular_now","maxAverageScore","minAverageScore","placesScoredAveraged","likes_score","venue_score","place_vibe_count","aggregate_score","aggregate_rating_count_score","aggregate_rating_score","maxDistance","distance_score","reasons","scores","largestIndex","apply","average_score","reason","placesSortedAndNormalized","icon_size","numPlaces","shuffleTopPicks","reducePlaceProperties","fromEntries","numTop","topPlaces","slice","remainingPlaces","toTitleCase","charAt","toUpperCase","nearest_places","radius","places_temp","places_to_return","validate_check_in","threshold","in_jls","bounds_jls","polygon","turf_boolean","in_neighborhood","valid_neighborhoods_id","valid_neighborhoods_name","turf_point","neigh_dist","neighborhood","lng","in_bbox_helper","boundary","bbox","parsed_bbox","nearest_neighborhood","neighborhoods_ordered","challenge_badges_lookup","challenge_badges","badges","badge","associate_badge","badges_to_check","win_badges","ID","searchCities","newCity","foundCity","searchTags","getAllBoundaries","admin_level","getBoundary","cache_bust","searchPlacesByName","apiURL","apiResult","suggestPlacesByName","string","context","geoContext","fullURL","name_suggest_context","name_suggest__completion","sortNeighborhoodsByVibes","vibeSlugs","relatedVibeSlugs","getRelatedVibes","vibeSlugsToIntersect","Set","neighborhoodsWithVibeIntersection","neighborhoodVibes","neighborhoodVibeSlugs","vibeIntersection","sortedNeighborhoods","restOfNeighborhood","uploadImageKit","file_path","image_data","json","base64","post","status","uploadVibemapImage","hotspots_place_id","filename","size","src"],"mappings":"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"}