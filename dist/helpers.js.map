{"version":3,"file":"helpers.js","sources":["../utils/helpers.js"],"sourcesContent":["import LinearScale from 'linear-scale'\n\nimport * as turf from '@turf/helpers'\nimport turf_distance from '@turf/distance'\nimport turf_boolean from '@turf/boolean-point-in-polygon'\n\nimport { getLocationFromPoint, sortLocations, distanceBetweenLocations } from './map'\nimport { getRelatedVibes } from './vibes'\n\n// TODO: Use only axios or fetch, not both\nimport Axios from \"axios\"\nimport axiosRetry from 'axios-retry'\n\naxiosRetry(Axios, {\n  retries: 3,\n  retryDelay: axiosRetry.exponentialDelay\n})\n\nimport isBetween from 'dayjs/plugin/isBetween'\nimport truncate from 'truncate'\n\nimport dayjs from 'dayjs'\nimport utc from 'dayjs/plugin/utc'\ndayjs.extend(isBetween)\ndayjs.extend(utc)\nimport dayjsRecur from 'dayjs-recur'\ndayjs.extend(dayjsRecur)\n\nimport querystring from 'querystring'\n\nconst wordpress = require('../dist/wordpress.js')\n\nimport * as constants from '../constants/constants.js'\n\nconst activityCategories = require('../dist/activityCategories.json')\nimport cities from '../constants/cities.json'\nimport neighborhoods from '../dist/neighborhoods.json'\nimport badges from '../dist/badges.json'\n\nconst ApiUrl = 'https://api.vibemap.com/v0.3/'\n\n// Filters a list of objects\n// Similar to .filter method of array\nexport const filterList = (\n  list = [{ test: 'test', value: 'foo' }, { test: 'test', value: 'bar'}],\n  searchTerm = 'food', key = 'value'\n) => {\n  // Generalize the Semantic UI search implementation\n  const re = new RegExp(searchTerm.replace(/[-[\\]{}()*+!<=:?.\\/\\\\^$|#\\s,]/g, '\\\\$&'), 'i')\n\n  const isMatch = (result) => re.test(result[key])\n\n  const results = list.filter(item => isMatch(item))\n\n  return results\n}\n\nexport const getRandomItem = (list) => {\n  // Get random index value\n  const randomIndex = Math.floor(Math.random() * list.length)\n\n  // Get random item\n  const item = list[randomIndex]\n\n  return item\n}\n\n// TODO: Option to encode / decode\nexport const encodeCardIndex = (row, column) => {\n  // Encode row / column into a decimal for sorting.\n  const index = row + column / 10\n\n  return index\n}\n\n// Counts the number of matches between the two lists and return and integer\nexport const matchLists = (listA, listB) => {\n  let matches = 0\n\n  if (listA.length > 0 && listB.length > 0) {\n    matches = listA.filter((word) => {\n      return listB.includes(word)\n    }).length\n  }\n\n  return matches\n}\n\n// Give a score based on the vibes position in the list.\nexport const rankVibes = (listA, listB) => {\n  let rankings = []\n\n  rankings = listA.map((word) => {\n    let score = 0\n\n    if (listB.includes(word)) {\n      score = listB.length - listB.indexOf(word)\n    }\n\n    return score\n  })\n\n  const average = rankings.reduce((a, b) => a + b, 0) / listB.length\n\n  return average\n}\n\nexport const sortByKey = (a, b) => {\n  console.log('sortByKey (a, b)', a, b)\n  return a\n}\n\nexport const sortByPopularity = (a, b) => {\n  return parseInt(b.details.msv) - parseInt(a.details.msv)\n}\n\nexport const sortByArray = (sortedList, sortingArr) => {\n  return sortedList.sort((a, b) => {\n    return sortingArr.indexOf(a) - sortingArr.indexOf(b)\n  })\n}\n\nexport const isClosedToday = (dailyHours) => {\n  return dailyHours.opens === '00:00:00' && dailyHours.closes === '00:00:00'\n}\n\nexport const displayHours = (hours, dayFormat = 'dd') => {\n  let openHours = isOpen(hours)\n  let hasHours = false\n\n  const weeklyHours = hours.find(({day_of_week}) => day_of_week === 8)\n\n  if (openHours.openEveryday) {\n    let times = []\n    const time =\n      dayjs(openHours.opens).format('ha') +\n      '-' +\n      dayjs(openHours.closes).format('ha')\n    times.push(time)\n\n    let popularFound = hours.find((day) => day.name == 'POPULAR')\n    console.log('Popular at: ', popularFound)\n\n    return times\n  }\n\n  let i = 0\n  let orderedHours = []\n\n  // Check every day of the week.\n  while (i < 7) {\n    // Get Label\n\n    let dayFound = hours.find((day) => day.day_of_week == i)\n    let popularFound = hours.find(\n      (day) => day.day_of_week == i && day.name == 'POPULAR'\n    )\n\n    // TODO: Handle popular vs normal\n    //console.log('Found day and popular times: ', dayFound, popularFound)\n\n    let isClosed = false\n\n    if (dayFound !== undefined) {\n      isClosed = isClosedToday(dayFound)\n\n      // We have some hours for the place\n      if (!isClosed) hasHours = true\n      //console.log('Day has hours: ', i, dayFound, popularFound, hasHours)\n    }\n\n    // If found and not closed\n    if (dayFound === undefined || isClosed) {\n      //const displayHours = helpers.displayHours(dayFound)\n      // Will with daily hours if available\n      if (!isClosed && weeklyHours !== undefined) {\n        // Set for current day\n        let time = Object.assign({}, weeklyHours)\n        time.day_of_week = i\n        orderedHours.push(time)\n        // Include closed days as closed\n      } else {\n        orderedHours.push({day_of_week: i, closed: true})\n      }\n    } else {\n      dayFound.closed = false\n      orderedHours.push(dayFound)\n    }\n    i++\n  }\n\n  // TODO: Add patterns for nicer formating.\n  // TODO: Handle localization and React templates\n  let formattedHours = orderedHours.map((dailyHours) => {\n    //console.log('formattedHours for: ', dailyHours)\n    // Shift days by 1; Monday = 1; Sunday = 0\n    const day = (dailyHours.day_of_week + 1) % 7\n\n    if (dailyHours.closed === true) {\n      return dayjs().day(day).format(dayFormat) + ': ' + 'Closed'\n    } else {\n      const opens = dailyHours.opens.split(':')\n      const closes = dailyHours.closes.split(':')\n\n      const time =\n        dayjs().day(day).format(dayFormat) +\n        ': ' +\n        dayjs().hour(opens[0]).minute(opens[1]).format('ha') +\n        '-' +\n        dayjs().hour(closes[0]).minute(closes[1]).format('ha')\n\n      return time\n    }\n  })\n\n  return formattedHours\n}\n\nexport const isOpen = (hours, time = dayjs()) => {\n  const day = time.day()\n  const date = time.format('YYYY-MM-DD')\n  const hour = time.hour()\n\n  if (!hours) return {openNow: false, openToday: false, isPopular: false}\n\n  let dayFound = hours.find(({day_of_week}) => day_of_week === day)\n\n  // TODO: not true if it's closed one day\n  const hasDailyHours = hours.find(({day_of_week}) => day_of_week === 8)\n\n  const daysClosed = hours.filter((day) => isClosedToday(day))\n\n  const openEveryday = hasDailyHours !== undefined && daysClosed.length == 0\n\n  // If open everyday and no specific hours for current day\n  if (openEveryday !== undefined && dayFound === undefined) {\n    dayFound = hasDailyHours\n  }\n\n  if (dayFound) {\n    const opens = dayjs(date + ' ' + dayFound.opens)\n    const closes = dayjs(date + ' ' + dayFound.closes)\n\n    // Return if open and if it's a popular time\n    const openNow = time.isBetween(opens, closes)\n    const isPopular = openNow && dayFound.name === 'POPULAR'\n    const hoursToday = opens.format('ha') + ' - ' + closes.format('ha')\n\n    return {\n      openNow: openNow,\n      openToday: true,\n      openEveryday: openEveryday,\n      opens: opens,\n      closes: closes,\n      isPopular: isPopular,\n    }\n  } else {\n    return {\n      openNow: false,\n      openToday: false,\n      openEveryday: false,\n      isPopular: false,\n    }\n  }\n}\n\nexport const getCardOptions = (block) => {\n  let postData = block.singCards.posts\n\n  let {\n    categoryQuery,\n    distanceQuery,\n    geoQuery,\n    placeType,\n    searchQuery,\n    vibeQuery } = postData[0]\n\n  // If a vibe override query is present\n  if (block.overrideQuery && block.overrideQuery.vibe) vibeQuery = block.overrideQuery.vibe\n\n  // Use city as a back up\n  if (block.overrideQuery && block.overrideQuery.cities && block.overrideQuery.cities.length > 0) {\n    const selectedCity = cities.filter(result => result.slug === block.overrideQuery.cities[0])\n\n    // TODO: Update this programatically from Wordpress\n    const cityRadius = 7\n    geoQuery = geoQuery ? geoQuery : selectedCity[0].location\n    distanceQuery = distanceQuery ? distanceQuery : cityRadius\n  }\n\n  if (block.overrideQuery && block.overrideQuery.location) {\n    geoQuery = block.overrideQuery.location\n\n    distanceQuery = block.overrideQuery.distance ? block.overrideQuery.distance : distanceQuery\n  }\n\n  // If no city or override are passed, make Oakland default\n  if (!geoQuery) {\n    const firstCity = cities.filter(result => result.slug === 'oakland')\n    geoQuery = firstCity[0].location\n  }\n\n  if (typeof vibeQuery === 'string') vibeQuery = vibeQuery.replace(/\\s/g, '').split(\",\") // Cast comma-separated list to array\n\n  // Map all the vibe slug to a list that includes related vibes.\n  const vibesFromCategories = vibeQuery ? vibeQuery.map(vibe => typeof(vibe) === 'string' ? vibe : vibe.slug) : []\n\n  // TODO: Move get relateed vibes to the backend or front end, not here.\n  //const allVibes = vibes.getRelatedVibes(vibesFromCategories)\n\n  let cardOptions = {\n    category: categoryQuery,\n    distance: distanceQuery,\n    point: geoQuery.longitude + ',' + geoQuery.latitude,\n    ordering: 'vibe',\n    search: searchQuery,\n    vibes: vibesFromCategories\n  }\n\n  return cardOptions\n\n}\n\nexport const getAPIParams = (options, per_page = 50) => {\n  let {activity, distance} = options\n  let params = Object.assign({}, options)\n\n  let distanceInMeters = 1\n  if (distance > 0)\n    distanceInMeters = Math.round(distance * constants.METERS_PER_MILE)\n\n  // API currently doesn't support other options\n  // However, the sorting algorithm, will use them\n  params['ordering'] = options.ordering\n    ? options.ordering\n    : '-aggregate_rating'\n\n  // TODO: Load more points at greater distances?\n  params['per_page'] = per_page\n\n  // Rename args\n  if (activity !== 'all' && activity !== null) params['category'] = activity\n  params['dist'] = distanceInMeters\n  delete params['activity']\n  delete params['distance']\n  delete params['bounds']\n\n  if (params.category == null) delete params['category']\n  if (params.search == null) delete params['search']\n  if (params.vibes == null) delete params['vibes']\n  //console.log('distanceInMeters', distanceInMeters, params['dist'])\n\n  return params\n}\n\n// Return all matching Vibemap categories\nexport const getCategoryMatch = (categories = ['all']) => {\n  const all_categories = activityCategories.activityCategories.map(\n    (category) => category.slug\n  )\n\n  let matches = []\n  /* TODO: use a combination of filter & map */\n  categories.map((category) => {\n    if (all_categories.includes(category)) {\n      matches.push(category)\n    }\n    return true\n  })\n\n  return matches\n}\n\n// Parse all variety of social links and return a consistent, valid url\nexport const getFullLink = (link, type = 'instagram') => {\n  const domains = {\n    instagram: 'https://instagram.com/',\n    twitter: 'https://twitter.com/',\n    facebook: 'https://facebook.com/',\n  }\n\n  // Handle things that aren't valid string handles\n  // TODO: add unit tests for link = null; link = '' and other cases\n  if (link === null || link === '') return null\n\n  const parse_url = url.parse(link)\n\n  // TODO: Just use the native URL methods:\n  let url = new URL(link)\n  //const path = url.pathname\n\n\n  // Only the path handle\n  const path = parse_url.path.replace('/', '')\n\n  // Combine domain and handle\n  const full_link = domains[type] + path\n\n  return full_link\n}\n\n// Give a city object return it's center coordinates as an array\nexport const geLocationFromCity = (city) => {\n  // Handles both the object form the CMS and vibemap-constants\n  // TODO: Consolidate to just vibemap-constants\n  const centerPoint = city.cityDetails\n    ? city.cityDetails.placemarker\n    : city.location\n      ? city.location\n      : null\n\n  return centerPoint\n}\n\nexport const getMax = (items, attribute) => {\n  let max = 0\n  items.forEach((item) => {\n    let value = item['properties'][attribute]\n    if (value > max) {\n      max = value\n    }\n  })\n\n  return max\n}\n\nexport const getMin = (items, attribute) => {\n  let min = 100\n  items.forEach((item) => {\n    let value = item['properties'][attribute]\n    if (value < min) {\n      min = value\n    }\n  })\n\n  return min\n}\n\n// Adapted from https://gist.github.com/James1x0/8443042\nexport const getTimeOfDay = (time) => {\n  var time_of_day = null //return g\n\n  //if we can't find a valid or filled moment, we return.\n  if (!time || !time.isValid()) {\n    return\n  }\n\n  var split_afternoon = 12 // 24hr time to split the afternoon\n  var split_evening = 17 // 24hr time to split the evening\n  var currentHour = parseFloat(time.format('HH'))\n\n  if (currentHour >= split_afternoon && currentHour <= split_evening) {\n    time_of_day = 'afternoon'\n  } else if (currentHour >= split_evening) {\n    time_of_day = 'evening'\n  } else {\n    time_of_day = 'morning'\n  }\n\n  return time_of_day\n}\n\nexport const getTopVibes = (places) => {\n  let top_vibes = {}\n\n  places.map((place) => {\n    place.properties.vibes.map((vibe) => {\n      if (top_vibes.hasOwnProperty(vibe)) {\n        top_vibes[vibe] += 1\n      } else {\n        top_vibes[vibe] = 1\n      }\n      return null\n    })\n    return null\n  })\n\n  var sortable = []\n  for (var vibe in top_vibes) {\n    sortable.push([vibe, top_vibes[vibe]])\n  }\n\n  let top_vibes_sorted = sortable.sort(function (a, b) {\n    return b[1] - a[1]\n  })\n\n  return top_vibes_sorted\n}\n\nexport const getTopCategories = (places, attribute = 'categories') => {\n  let top_categories = {};\n\n  places.map((place) => {\n    place.properties[attribute].map((item) => {\n      if (top_categories.hasOwnProperty(item)) {\n        top_categories[item] += 1;\n      } else {\n        top_categories[item] = 1;\n      }\n      return null\n    });\n    return null\n  });\n\n  var sortable = [];\n  for (var item in top_categories) {\n    sortable.push([item, top_categories[item]]);\n  }\n\n  let top_categories_sorted = sortable.sort(function (a, b) {\n    return b[1] - a[1]\n  });\n\n  return top_categories_sorted\n}\n\nexport const getWaveFromVibe = (vibe) => {\n  switch (vibe) {\n    case 'buzzing':\n      return 'high'\n    default:\n      return 'medium'\n  }\n\n  //console.log('Get wave level for vibe: ', vibe, waveLevel)\n\n  return waveLevel\n}\n\nexport const graphToEvents = (edges = []) => {\n  const events = edges.map(edge => {\n    const groupEvent = edge.node\n    const details = groupEvent.groupDetails\n\n    const name = details.name\n    const link = details.link\n    const slug = groupEvent.slug\n    const description = details.description\n    // TODO: Handle multiple images\n    const image = details.image\n      ? details.image.url\n      : null\n    const images = [{\n      url: image,\n      original: image\n    }]\n    const location = details.map\n    const price = details.price ?\n      details.price :\n      `free`\n\n    const vibes = details.vibes ?\n      details.vibes.map(vibe => vibe.slug) : []\n\n    const recurring = details.recurring\n    const recurrence = details.recurrence\n    const which = details.which\n    const day = details.day.value\n\n    const startTime = details.startTime ?\n      details.startTime :\n      `00:00`\n    const endTime = details.startTime ?\n      details.endTime :\n      `00:00`\n\n    const recurRule = nextDateFromRecurring(recurrence, day, which)\n\n    const nextStartTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, startTime))\n\n    const nextEndTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, endTime))\n\n    const event = {\n      id: slug,\n      title: name,\n      geometry: {\n        type: \"Point\",\n        coordinates: [-122.26747099999956, 37.81396520000001]\n      },\n      dateTime: nextStartTime,\n      image: images,\n      type: `event`,\n      properties: {\n        name: name,\n        title: name,\n        url: link,\n        address: location && location.streetAddress,\n        categories: [],\n        city: details.cities && details.cities[0].slug,\n        description: description,\n        is_online: false,\n        images: [],\n        hotspots_place: location,\n        location: location,\n        start_date: nextStartTime,\n        end_date: nextEndTime,\n        vibemap_images: images,\n        likes: 10,\n        price: price,\n        recurs: true,\n        vibes: vibes\n      }\n    }\n\n    return event\n  })\n\n  return events\n}\n\nexport const groupsToEvents = (groups = []) => {\n  const events = groups.map(groupEvent => {\n    //const groupEvent = edge.node\n    const details = groupEvent.acf\n\n    const name = details.name\n    const link = details.link\n    const slug = groupEvent.slug\n    const description = details.description\n    // TODO: Handle multiple images\n    const image = details.image && details.image.url\n    const images = image\n      ? [{\n        url: image,\n        original: image\n      }]\n      : []\n\n    const location = details.map\n    const price = details.price ?\n      details.price :\n      `free`\n\n    const vibes = details.vibes ?\n      details.vibes.map(vibe => vibe.slug) : []\n\n    const recurring = details.recurring\n    const recurrence = details.recurrence\n    const which = details.which\n    const day = details.day && details.day.label\n      ? details.day.label\n      : `sunday`\n\n    const startTime = details.start_time ?\n      details.start_time :\n      `00:00`\n    const endTime = details.end_time ?\n      details.end_time :\n      `00:00`\n\n    const recurRule = nextDateFromRecurring(recurrence, day, which)\n\n    const nextStartTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, startTime))\n\n    const nextEndTime = dayjs(recurRule.next(1).toLocaleString()\n      .replace(`00:00:00`, endTime))\n\n    const event = {\n      id: slug,\n      title: name,\n      geometry: {\n        type: \"Point\",\n        coordinates: [-122.26747099999956, 37.81396520000001]\n      },\n      dateTime: nextStartTime.toISOString(),\n      image: images,\n      type: `event`,\n      properties: {\n        name: name,\n        title: name,\n        url: link,\n        address: location && location.streetAddress,\n        categories: [],\n        city: details.cities && details.cities[0].slug,\n        description: description,\n        is_online: false,\n        images: images,\n        hotspots_place: location,\n        location: location,\n        start_date: nextStartTime.toISOString(),\n        end_date: nextEndTime.toISOString(),\n        vibemap_images: images,\n        likes: 10,\n        price: price,\n        recurs: true,\n        vibes: vibes\n      }\n    }\n\n    return event\n  })\n\n  return events\n}\n\n// This function is no longer utilized. Linear scale from 0 to 10\nexport const normalize = (val, min, max) => {\n  return ((val - min) / (max - min)) * 10\n}\n\n/* New flexible linear scaling function. Using d3.scaleLinear, a value (val) between\nmin and max is scaled appropriately to value between scale_low and scale_high\n*/\nexport const normalize_all = (val = 500, min = 1, max = 100, scale_low = 1, scale_high = 10) => {\n\n  const scale = LinearScale().domain([min, max]).range([scale_low, scale_high])\n  //console.log(`linear-scale result `, scale(val))\n\n  return scale(val)\n}\n\n// TODO Function for scaling icon. Currently bug (likely in clustering) where certain icon's become very small\nexport const scaleIconSize = (score = 5, min = 1, max = 100) => {\n  const minSize = 1\n  const maxSize = 5\n\n  // TODO: Test and replace\n  //const d3_scale = scaleLinear().domain([min, max]).range([1, 5])\n\n  const scale = LinearScale()\n    .domain([min, max])\n    .range([minSize, maxSize])\n\n  const iconSize = scale(score)\n\n  return iconSize\n}\n\nexport const scaleMarker = (score = 50, min = 0, max = 100, zoom = 14) => {\n  // TODO: Hack to catch empty/nan scores\n  if (isNaN(score)) score = 3.5\n\n  const marker_scale = LinearScale()\n    .domain([8, 20])\n    .range([10, 30])\n\n\n  let base_marker = marker_scale(zoom)\n  let max_marker = base_marker * 3\n\n  let scale = LinearScale()\n    .domain([0, max])\n    .range([base_marker, max_marker])\n\n  let scaled_size = Math.round(scale(score))\n\n  return scaled_size\n}\n\n// Maps the relative density of place to a known range for Vibemap's cities\nexport const scaleDensityArea = (density = 10, area = 100) => {\n  // TODO: Make these contants?\n  let density_scale = LinearScale()\n    .domain([1, 60, 1000])\n    .range([0, 0.8, 1])\n\n  let relative_density = density_scale(density)\n\n  return relative_density\n}\n\nexport const scaleDensityBonus = (relative_density) => {\n  let inverted_scale = LinearScale()\n    .domain([0, 1])\n    .range([constants.HEATMAP_INTENSITY * 2, constants.HEATMAP_INTENSITY])\n\n  const withBonus = inverted_scale(relative_density)\n  return withBonus\n}\n\nexport const scaleScore = (score = 2) => {\n  let scale = LinearScale()\n    .domain([0, 5])\n    .range([60, 100])\n\n  let percentage = Math.round(scale(score))\n\n  return percentage\n}\n\nexport const scaleSelectedMarker = (zoom) => {\n  // Scale em size of svg marker to zoom level\n  let scale = LinearScale()\n    .domain([8, 12, 20]) // Zoom size\n    .range([0.1, 1.2, 4]) // Scale of marker size\n\n  let scaled_size = Math.round(scale(zoom))\n\n  return scaled_size\n}\n\nexport const getEventOptions =  (\n  city = 'oakland',\n  date_range = 'month',\n  distance = 10,\n  category = null,\n  vibes = [],\n  search\n  ) => {\n    const selectedCity = cities.filter(result => result.slug === city)\n    // FIXME: Why is the location sometimes missing\n    const location = selectedCity ? selectedCity[0].location : cities[0]\n\n    const today = dayjs()\n    const dayOfWeek = today.day() + 1\n\n    let day_start = today.startOf('day')\n\n    let startOffset = 0\n    let endOffset = 0\n\n    switch (date_range) {\n      case 'day':\n        endOffset = 1\n        break;\n\n      case 'weekend':\n        endOffset = 7 - dayOfWeek\n        break;\n\n      case 'next_week':\n        startOffset = 8 - dayOfWeek\n        endOffset = 7\n        break;\n\n      case 'month':\n        const monthEnd = dayjs().endOf('month')\n        endOffset = monthEnd.diff(today, 'day')\n\n      case 'quarter':\n        endOffset = 90\n        break;\n    }\n\n    let date_range_start = today.add(startOffset, 'days').startOf('day')\n    let date_range_end = today.add(endOffset , 'days').endOf('day') //  TODO Plus range\n\n    const options = {\n      category: category,\n      distance: distance,\n      point: location.longitude + ',' + location.latitude,\n      ordering: 'vibe',\n      start_date: date_range_start.format(\"YYYY-MM-DD HH:MM\"),\n      end_date: date_range_end.format(\"YYYY-MM-DD HH:MM\"),\n      search: search,\n      vibes: vibes\n    }\n\n    return options\n}\n\nexport const fetchEvents = async (\n  // Defaults for testing\n  options = {\n    distance: 20,\n    point : `-122.269994,37.806507`\n  },\n  activitySearch = false) => {\n\n  let {\n    activity,\n    bounds,\n    category,\n    days,\n    distance,\n    ordering,\n    point,\n    search,\n    time,\n    vibes,\n  } = options\n\n  let centerPoint = point.split(',').map((value) => parseFloat(value))\n  let currentLocation = getLocationFromPoint(centerPoint)\n  let distanceInMeters = distance * constants.METERS_PER_MILE\n\n  let day_start = dayjs().startOf('day').format('YYYY-MM-DD HH:MM')\n  let day_end = dayjs().add(days, 'days').format('YYYY-MM-DD HH:MM')\n\n  if (activitySearch && category) {\n    options.search = `${category ? category : ''} ${search ? search : ''}`\n  }\n\n  const nearestCities = sortLocations(cities, currentLocation)\n  const city = nearestCities && nearestCities.length > 0\n    ? nearestCities[0].name\n    : null\n\n  const params = module.exports.getAPIParams(options)\n  let query = querystring.stringify(params)\n\n  const apiEndpoint = `${ApiUrl}events/`\n  const source = Axios.CancelToken.source()\n\n  let response = await Axios.get(`${apiEndpoint}?${query}`, {\n    cancelToken: source.token,\n  }).catch(function (error) {\n    // handle error\n    console.log('Axios error ', error.response.statusText)\n\n    return {\n      data: [],\n      count: 0,\n      top_vibes: null,\n      loading: false,\n      timedOut: false\n    }\n  })\n\n  // TODO: How to filter by location and category / vibe\n  const groups = await wordpress.getGroups({ city: city ? city : '' })\n  const recurringGroupEvents = groupsToEvents(groups.data)\n\n  response.data.results.features = recurringGroupEvents.concat(response.data.results.features)\n\n  return response\n}\n\nconst nextDateFromRecurring = (...[\n  recurrence,\n  day,\n  which\n]) => {\n  const date = dayjs() // .startOf('month')\n  const ordinals = [\"first\", \"second\", \"third\", \"fourth\", \"fifth\"]\n  const whichDay = ordinals.indexOf(which)\n  const weekOfMonth = whichDay > 0 ? whichDay : 0\n\n  // TODO: Handle daily, quarterly, yearly\n  // And pass this same util to the details page\n  const recurRule = recurrence == `monthly` ?\n    date.recur()\n      .every(day).daysOfWeek() // By day name\n      .every([weekOfMonth]).weeksOfMonthByDay() // By which week of the month\n    :\n    date.recur()\n      .every(day).daysOfWeek() // Same day every week\n\n  return recurRule\n}\n\nexport const fetchPlacesDetails = async (id, type = 'place') => {\n  const source = Axios.CancelToken.source()\n  let apiEndpoint\n  let category = \"\"\n\n  if (type == \"event\") {\n    apiEndpoint = `${ApiUrl}events/`\n    category = `Event`\n  }\n\n  if (type == \"place\") {\n    apiEndpoint = `${ApiUrl}places/`\n    category = `Place`\n  }\n\n  if (apiEndpoint) {\n    const response = await Axios.get(`${apiEndpoint}${id}`, {\n      cancelToken: source.token,\n    }).catch(function (error) {\n      // handle error\n      console.log('Axios error ', error.statusText);\n      return null\n    })\n\n    let subcategory = category\n\n    return response\n  }\n}\n\n// Fetch Places from API with query params including\n// - categories\n// - vibes\n// - search\nexport const fetchPlacePicks = async (\n  options = {\n    distance: 5,\n    point: '-123.1058197,49.2801149',\n    ordering: '-vibe',\n    vibes: ['chill'],\n    preferredVibes: [],\n    relatedVibes: [] // TODO: Separate query by * score by\n  }\n) => {\n  let {\n    activity,\n    bounds,\n    category,\n    days,\n    distance,\n    ordering,\n    per_page,\n    point,\n    search,\n    time,\n    vibes,\n    preferredVibes,\n    relatedVibes,\n  } = options\n\n  let distanceInMeters = 1\n  if (distance > 0) distanceInMeters = distance * constants.METERS_PER_MILE\n  if (activity === 'all') activity = null\n\n  const scoreBy = ['aggregate_rating', 'vibes', 'distance', 'offers', 'hours']\n  const numOfPlaces = per_page ? per_page : 500\n  const hasVibes = vibes && vibes.length > 0\n\n  let centerPoint = point.split(',').map((value) => parseFloat(value))\n  let currentLocation = getLocationFromPoint(centerPoint)\n  const nearestCities = sortLocations(cities, currentLocation)\n  const distanceFrom = distanceBetweenLocations(nearestCities[0].location, currentLocation)\n\n  // Use city if nearby, for better caching\n  if (distanceFrom < 200) {\n    const city = nearestCities[0]\n    options.point = city.centerpoint.join(',')\n  }\n\n  const apiEndpoint = ApiUrl + 'places/'\n  const source = Axios.CancelToken.source()\n\n  let response = {}\n  const getPlaces = async (options) => {\n    const params = getAPIParams(options, numOfPlaces)\n    let query = querystring.stringify(params)\n    //console.log(`Places search query is `, `${apiEndpoint}?${query}`);\n\n    response = await Axios.get(`${apiEndpoint}?${query}`, {\n      cancelToken: source.token,\n    }).catch(function (error) {\n      // handle error\n      console.log('Axios error ', error.response.statusText);\n\n      return {\n        data: [],\n        count: 0,\n        query: '?' + query,\n        top_vibes: null,\n        loading: false,\n        timedOut: false,\n      }\n    })\n\n    return response\n  }\n\n  response = await getPlaces(options)\n\n  const count = response.data.count\n\n  // FIXME: Workaround to retry with search\n  if (count == 0 && hasVibes) {\n    let newOptions = Object.assign({}, options)\n    newOptions.search = vibes[0]\n    newOptions.vibes = []\n\n    response = await getPlaces(newOptions)\n    //response = await\n  }\n\n  let places = formatPlaces(response.data.results.features)\n\n  //console.log('Got reponse ', response.data)\n\n  const vibesQuery = vibes ? vibes : []\n\n  // TODO: Consider scoring related vibe differently\n  const vibesCombined = vibesQuery\n    .concat(preferredVibes ? preferredVibes : [])\n\n  const newOptions = {\n    ...options,\n    relatedVibes: relatedVibes\n  }\n\n  // TODO: Incorporate personalized vibe score for user\n  let placesScoredAndSorted = scorePlaces(\n    places,\n    centerPoint,\n    vibesCombined,\n    scoreBy,\n    ordering,\n    undefined,\n    newOptions // Pass any overrides\n  )\n\n  let top_vibes = getTopVibes(places)\n\n  return {\n    data: placesScoredAndSorted,\n    count: count,\n    top_vibes: top_vibes,\n    loading: false,\n    timedOut: false,\n  }\n}\n\n// Handle fields from the tile server\nexport const decodePlaces = (places) => {\n  const decoded = places.map((feature) => {\n    //console.log('feature: ', feature)\n    feature.properties.vibes = JSON.parse(feature.properties.vibes)\n    feature.properties.subcategories = JSON.parse(\n      feature.properties.subcategories\n    )\n    feature.properties.categories = JSON.parse(feature.properties.categories)\n    feature.properties.vibemap_images = []\n    feature.properties.images = [feature.properties.thumbnail_url]\n    if (feature.properties.opening_hours != undefined)\n      feature.properties.opening_hours = JSON.parse(\n        feature.properties.opening_hours\n      )\n    delete feature.properties.tips\n    //delete feature.properties.subcategories\n    delete feature.properties.facebook\n    delete feature.properties.telephone\n    delete feature.properties.website\n\n    return feature\n  })\n\n  return decoded\n}\n\n// Do some post-parsing clean up to the data\n// TODO: API Update for Places\nexport const formatPlaces = (places = []) => {\n  // TODO: Replace with activityCategories\n  const categories = activityCategories.activityCategories\n    .sort(sortByPopularity)\n    .map(category => category.slug)\n\n  const formatted = places.map((place) => {\n    let fields = place.properties\n\n    // Add fields for presentation\n    fields.place_type = 'places'\n    fields.short_name = truncate(fields.name, constants.TRUCATE_LENGTH)\n    fields.aggregate_rating = parseFloat(fields.aggregate_rating)\n    fields.num_vibes = fields.vibes.length\n\n    fields.sub_categories = fields.sub_categories\n    fields.top_vibe = null\n\n    const matchingCategories = fields.categories\n      .map(category => {\n        if (category == 'Drink') category = 'Drinking'\n        return category.toLowerCase()\n      })\n      .filter(category => categories.includes(category.toLowerCase()))\n\n    const sortedCategories = sortByArray(matchingCategories, categories)\n\n    if (fields.categories === undefined ||\n        fields.categories.length === 0 ||\n        matchingCategories.length === 0) {\n          fields.categories = ['missing']\n    }\n\n    // TODO: Add proper theming\n    const theme = 'light'\n    fields.icon = `icon_${sortedCategories[0]}_${theme}`\n    fields.cluster = null\n\n    place.properties = fields\n    return place\n  })\n  return formatted\n}\n\nexport const vibesFromPlaces = (places) => {\n  const vibes = []\n  // TODO: get frequency of vibes from a set of places\n  return vibes\n}\n\nexport const getRecommendedVibes = (vibes) => {\n  const recommended = []\n  // Find related and recommended vibes for the given set.\n  return recommended\n}\n\nexport const scorePlaces = (\n  places,\n  centerPoint,\n  vibes = [],\n  scoreBy = ['vibes', 'distance'],\n  ordering,\n  shuffle = true,\n  zoom = 12,\n  options = {}\n) => {\n  //console.log('scorePlaces: ', places, ordering, scoreBy)\n\n  // Default max values; These will get set by the max in each field\n  let maxScores = {}\n\n  // Bonuses between 1 and 10\n  // TODO reconfigure bonus scores in a way that is more mathematically sound\n  // to use zoom-weight scaling\n\n  const vibeMatchBonus = 10\n  const vibeRelatedBonus = 2\n  const vibeOrderBonus = 1\n  const vibeAmountBonus = 2\n  const offerBonus = 2\n  const imageBonus = 2\n  const openBonus = 0.5\n  const popularBonus = 5\n\n  // TODO: If ordered by vibe, rank matches very high\n  const vibeRankBonus = ordering == 'vibe' ? 30 : 20\n\n  // ⚡ \tFirst, initialize the scoring fields\n  //\t\tDefaults should be on extreme ends to prevent logical errors\n  let minScores = {};\n\n  scoreBy.map((field) => (maxScores[field] = 0.00001))\n  // Default min values; These will get set by the min in each field\n  scoreBy.map((field) => (minScores[field] = Infinity))\n\n  // Default any zoom level less than ten to be ten, not useful to weigh distance at that point\n  let zoom_to_use = zoom <= 10 ? 10 : zoom;\n  let zoom_norm = normalize_all(zoom_to_use, 10, 20, 0, 10)\n\n  // Logistic growth equation. Max weight is 8, minimum of 1. Weight grows exponentially in the middle range\n  // TODO: pull this out into own function, allows us to weigh distance differently depending on zoom\n  let zoom_weight = 8 / (1 + (7 * (Math.exp(1) ** (-0.7 * zoom_norm))))\n\n  // Weight distance & rating different than other fields\n  // TODO: Make everything a consitent 1-10 scale\n  let weights = {\n    category: 0,\n    vibe: 10,\n    distance: zoom_weight,\n    rating: 0,\n    hours: 0,\n    offers: 0,\n  }\n\n  // If there are vibes, weigh the strongest by 3x\n  // if (vibes.length > 0 && ordering === 'relevance') weights.vibe = 2\n  // Do the same for other sorting preferences\n  if (ordering !== 'relevance') weights[ordering] += 3\n\n  // Get scores and max in each category\n  const placesScored = places.map((place) => {\n    let fields = place.properties\n    fields.stats = {}\n\n    // Give place a vibe score\n    // TODO: Calculate `vibe_score` on backend with stored procedure.\n    // TODO: Make a separate, modular method\n    if (scoreBy.includes('vibes')) {\n      let [vibeMatches, relatedVibeMatches, averageRank, vibeBonus] = [0, 0, 0, 0]\n\n      fields.vibes_score = 0\n      // TODO: TEMP until events return vibes\n      if (fields.vibes === undefined) fields.vibes = ['chill']\n\n      // Based off logrithmic scale, a place with 20 vibes isn't that much (twice) better than one with 10\n      const scoreVibeLength = fields.vibes.length > 0\n        ? vibeAmountBonus * Math.log10(fields.vibes.length)\n        : 0\n\n      if (fields.vibes.length > 0) fields.vibes_score = scoreVibeLength\n\n      // Don't show markers without photos; this will analyze the vibe and quality of the image\n      //Reward photos logrithmically as well. Log indicates scaling behavior, coefficient the weight\n      if (fields.images && fields.images.length > 0) vibeBonus += fields.images.length > 0\n        ? imageBonus * Math.log10(fields.images.length)\n        : 0\n\n      // Give direct vibe matches bonus points\n      if (vibes && vibes.length > 0 && fields.vibes) {\n        vibeMatches = matchLists(vibes, fields.vibes)\n\n        relatedVibeMatches = options.relatedVibes ?\n          matchLists(options.relatedVibes, fields.vibes)\n          : 0\n        // The average rank scores by the order of the array\n        // That is the first vibe gets ranks higher than the last one\n        averageRank = rankVibes(vibes, fields.vibes)\n\n        // Bonus for exact matches + all place vibes\n        const vibeMatchScore = vibeMatches * vibeMatchBonus + relatedVibeMatches * vibeRelatedBonus\n        const vibeOrderScore = averageRank * vibeOrderBonus\n        vibeBonus += vibeMatchScore + vibeOrderScore\n        fields.vibes_score += vibeBonus\n\n        // For debugging purposes\n        fields.stats['num_vibes'] = fields.vibes.length\n        fields.stats['num_matching_vibes'] = vibeMatches\n        fields.stats['vibe_match_score'] = vibeMatchScore\n        fields.stats['vibe_order_score'] = vibeOrderScore\n      }\n\n      // Set max vibe score\n      if (fields.vibes_score > maxScores.vibes) {\n        maxScores.vibes = fields.vibes_score\n      }\n\n      if (fields.vibes_score < minScores.vibes) {\n        minScores.vibes = fields.vibes_score\n      }\n\n      //console.log('Scoring weights: ', weights, ordering, vibeRankBonus)\n      //console.log('For these vibes: ', fields.vibes)\n      //console.log('Vibe score bonus: ', fields.vibes_score, vibeBonus)\n      //console.log('Vibe order bonus: ', fields.vibes_score, vibeBonus)\n      //console.log('Vibe score: ', vibeMatches, averageRank, vibeBonus)\n      fields.stats['total_vibe_score'] = fields.vibes_score\n    }\n\n    // Get scores and max in each category\n    // TODO: Make a separate, modular method\n    if (scoreBy.includes('categories')) {\n      let [categoryMatches, averageRank, vibeBonus] = [0, 0, 0]\n\n      fields.categories_score = 0\n\n      // Merge and remove duplicates\n      const concatCategories = fields.categories.concat(fields.subcategories);\n      const allCategories = concatCategories.filter(\n        (item, index) => concatCategories.indexOf(item) == index\n      );\n\n      if (fields.categories.length > 0)\n        fields.categories_score = fields.categories.length\n      //console.log('Base category score: ', fields.categories_score, allCategories)\n\n      // Give matching categories for the vibe a bonus\n      if (vibes.length > 0) {\n        // Get vibes for the place category\n        let categoryVibes = []\n        allCategories.forEach((category) => {\n          //console.log('Category: ', fields.name, category)\n          // TODO: There probably a cleaner way to search for both categories and subcategories\n          const foundCategories = constants.place_sub_categories.filter((o) =>\n            o.main_category.includes(category)\n          );\n          const foundSubcategories = constants.place_sub_categories.filter(\n            (o) => o.name.includes(category)\n          );\n\n          if (foundCategories.length > 0) {\n            categoryVibes = categoryVibes.concat(foundCategories[0].vibes);\n          }\n\n          if (foundSubcategories.length > 0) {\n            categoryVibes = categoryVibes.concat(foundSubcategories[0].vibes);\n          }\n        });\n\n        categoryMatches = matchLists(vibes, categoryVibes)\n        const bonus = categoryMatches * vibeMatchBonus\n        fields.categories_score += bonus\n      }\n\n      if (fields.categories_score > maxScores['categories']) {\n        maxScores['categories'] = fields.categories_score;\n      }\n      if (fields.categories_score < minScores['categories']) {\n        minScores['categories'] = fields.categories_score;\n      }\n    }\n\n    // Get the min and max scores for normalization\n    // Add score for the number of likes or RSVPs for events\n    if (scoreBy.includes('likes')) {\n      // Set max aggregate score\n      if (fields.likes > maxScores['likes']) {\n        maxScores['likes'] = fields.likes\n      }\n\n      if (fields.likes < minScores['likes']) {\n        minScores['likes'] = fields.likes\n      }\n    }\n\n    // Add score for distance from user\n    if (scoreBy.includes('distance')) {\n      // TODO: Make a util in map.js\n      const placePoint = turf.point(place.geometry ? place.geometry.coordinates : [0, 0])\n\n      // Does this return in kilometers? Miles?\n      fields['distance'] = turf_distance(centerPoint, placePoint)\n      // Set max distance\n      if (fields['distance'] > maxScores['distance']) {\n        maxScores['distance'] = fields['distance']\n      }\n      if (fields['distance'] < minScores['distance']) {\n        minScores['distance'] = fields['distance']\n      }\n    }\n\n    if (scoreBy.includes('aggregate_rating')) {\n      // Set max aggregate score\n      if (fields.aggregate_rating > maxScores['aggregate_rating']) {\n        maxScores['aggregate_rating'] = fields.aggregate_rating\n      }\n      if (fields.aggregate_rating < minScores['aggregate_rating']) {\n        minScores['aggregate_rating'] = fields.aggregate_rating\n      }\n    }\n\n    // TODO: WIP concept for popular times and hours\n    // TODO: Move to backend or make a separate, modular method\n    //console.log('Score place on these fields: ', fields.offers, fields.opening_hours)\n    fields.offers_score = 0\n    fields.hours_score = 0\n\n    // Give bonus if place has offers or is open\n    if (scoreBy.includes('offers')) {\n      if (fields.offers && fields.offers.length > 0) {\n        fields.offers_score = offerBonus\n      }\n\n      let { openNow, openToday, opens, closes, isPopular } = isOpen(\n        fields.opening_hours\n      );\n\n      // Store in place details\n      // TODO: Make sure these field name match the upgraded API\n      fields.open_now = openNow\n      fields.popular_now = isPopular\n      fields.opens = opens\n      fields.closes = closes\n\n      // Give bonus if open now\n      if (openToday) fields.hours_score += openBonus\n      if (openNow) fields.hours_score += openBonus\n      if (isPopular) fields.hours_score += popularBonus\n    }\n\n    fields.stats['hours_bonus'] = fields.hours_score\n\n    place.properties = fields\n    return place\n  });\n\n  // Now normalize all the scores\n  let maxAverageScore = 0\n  let minAverageScore = Infinity\n\n  // Normalize each place by the top scores across all results\n  let placesScoredAveraged = placesScored.map((place) => {\n    let fields = place.properties\n\n    // TODO: This could be more steamlined automatically for each key in scoreBy\n    if (scoreBy.includes('vibes')) {\n      fields.vibes_score = normalize_all(fields.vibes_score, minScores['vibes'], maxScores['vibes'], 0, 1)\n      fields.vibes_score = fields.vibes_score * weights['vibe']\n      //console.log('fields.vibes_score: ', fields.name, fields.vibes_score)\n    }\n\n    if (scoreBy.includes('categories')) {\n      fields.categories_score = normalize_all(\n        fields.categories_score, minScores['categories'], maxScores['categories'], 0, 1);\n      fields.categories_score = fields.categories_score * weights['category']\n      //console.log('fields.categories_score: ', fields.name, fields.categories_score)\n    }\n\n    if (scoreBy.includes('likes')) {\n      fields.likes_score = normalize_all(fields.likes, minScores['likes'], maxScores['likes'], 0, 1)\n    }\n\n    // Get average rating and scale it by a factor\n    if (scoreBy.includes('aggregate_rating')) {\n      fields.aggregate_rating_score = normalize_all(\n        fields.aggregate_rating, minScores['aggregate_rating'], maxScores['aggregate_rating'], 0, 1)\n      fields.aggregate_rating_score *= weights.rating\n      fields.stats['aggregate_rating_score'] = fields.aggregate_rating\n    }\n\n    // Smallest distance gets largest score\n    if (scoreBy.includes('distance')) {\n      let maxDistance = maxScores['distance']\n\n      /* all distance values are normalized between 0 and 0.95. Since we take the difference of 1 and the score,\n        the lowest possible distance_score is 0.05, and the highest is 1. We do this such that lower distances\n        (closer places) get a higher distacne score.\n      */\n      fields.distance_score = 1 - normalize_all(fields.distance, minScores['distance'], maxDistance, 0, 0.95)\n\n      //console.log(fields.distance, minScores['distance'], maxDistance, maxDistance - fields.distance, fields.distance_score)\n      fields.distance_score *= weights.distance\n      fields.stats['distance_score'] = fields.distance_score\n    }\n\n\n    if (scoreBy.includes('hours')) {\n      fields.hours_score *= weights.hours\n    }\n\n    const reasons = scoreBy;\n    const scores = scoreBy.map((field) => fields[field + '_score'])\n\n    // Find the larged score\n    const largestIndex = scores.indexOf(Math.max.apply(null, scores))\n\n    // Find the smallest score\n\n    scores.indexOf(Math.min.apply(null, scores))\n\n    // Take an average of each of the scores\n    fields.average_score = scores.reduce((a, b) => a + b, 0) / scores.length\n    // Update the top average score\n    if (fields.average_score > maxAverageScore)\n      maxAverageScore = fields.average_score;\n\n    if (fields.average_score < minAverageScore)\n      minAverageScore = fields.average_score\n    // Add the update the reason code\n    fields.reason = reasons[largestIndex]\n    //console.log(`Top reason `, fields.name, fields.reason)\n\n    place.properties = fields\n    return place\n  })\n\n  // Re-sort by average score\n  const placesScoredAndSorted = placesScoredAveraged.sort(\n    (a, b) => b.properties.average_score - a.properties.average_score\n  )\n\n  // Normalize the scores between 0.65 and 1\n  const placesSortedAndNormalized = placesScoredAndSorted.map((place) => {\n    let fields = place.properties\n    //console.log(place.properties.name, minAverageScore, fields.average_score, maxAverageScore)\n\n    // ⚡⚡ final score returned to user is normalized between 0.65 and 1\n    fields.average_score = normalize_all(fields.average_score, minAverageScore, maxAverageScore, 0.65, 1)\n    fields.icon_size = scaleIconSize(fields.average_score, 0.65, 1)\n\n    // All average_scores should be between 0.65 and 1, and icon_size between 1 and 5. Should also print in descending order\n    //If so, then all is working well\n    //console.log(place.properties.name, place.properties.address, fields.average_score, fields.distance_score, weights.distance)//, fields.icon_size)\n    // Scale the icon size based on score\n    fields.stats['final_score_normalized'] = fields.average_score\n\n    return place\n  })\n\n  // TODO: for debugging only\n  /*placesSortedAndNormalized.map((place) => {\n    console.log(place.properties.name)\n    console.log(' - score: ', place.properties.average_score)\n    console.log(' - vibes_score: ', place.properties.vibes_score)\n    console.log(' - aggregate rating: ', place.properties.aggregate_rating_score)\n    console.log(' - distance: ', place.properties.distance_score, \"weight: \", weights.distance)\n    console.log(' - reason: ', place.properties.reason)\n    console.log(' - final_score_normalized: ', place.properties.average_score)\n  })\n  */\n\n  const numPlaces = placesSortedAndNormalized.length\n  const results = shuffle && numPlaces > 100\n    ? module.exports.shuffleTopPicks(placesSortedAndNormalized)\n    : placesSortedAndNormalized\n\n  return results\n}\n\n// Only return the requested fields and remove all others from GeoJSON properies\nexport const reducePlaceProperties = (\n  places,\n  fields = [\n    'name',\n    'url',\n    'address',\n    'categories',\n    'subcategories',\n    'neighborhood',\n    'price',\n    'short_description',\n    'vibemap_images',\n    'vibes'\n  ]) => {\n\n  const places_reduced = places.map(place => {\n    place.properties = Object.fromEntries(\n      fields.map(key => [key, place.properties[key]])\n    )\n    return place\n    //console.log('reduced this place ', place.properties)\n  })\n\n  return places_reduced\n}\n\nexport const shuffleTopPicks = (places, numTop = 20) => {\n  // Slice and Shuffle\n  const topPlaces = places.slice(0, numTop)\n    .map(value => ({ value, sort: Math.random() }))\n    .sort((a, b) => a.sort - b.sort)\n    .map(({ value }) => value)\n\n  // Store remainder\n  const remainingPlaces = places.slice(numTop)\n\n  // Combine and return all\n  const placesCombined = topPlaces.concat(remainingPlaces)\n  return placesCombined\n}\n\nexport const toTitleCase = (str) => {\n  if (typeof str == 'string') {\n    str = str.toLowerCase().split(' ')\n    for (var i = 0; i < str.length; i++) {\n      str[i] = str[i].charAt(0).toUpperCase() + str[i].slice(1)\n    }\n    return str.join(' ')\n  } else {\n    return str\n  }\n}\n\n\n// TODO: add neighborhood as top place of the list. Will need some neighborhood cards\n//Function that returns every place within a certain specified radius\nexport const nearest_places = (places, currentLocation, radius = 5) => {\n  //console.log(\"current Location: \", currentLocation)\n  //console.log(\"Full list of Places: \", places)\n\n  // Push any place whose distance is under radius (0.1) to places_temp\n  var places_temp = []\n  const distance_calculated = places.map((place) => {\n    let fields = place.properties\n    const placePoint = turf.point(place.geometry.coordinates)\n    fields['distance'] = turf_distance(currentLocation, placePoint)\n    if (fields['distance'] < radius) {\n      places_temp.push(place)\n      //console.log(\"Place within bound: \", fields[\"distance\"])\n    }\n  })\n\n  // Sort on a copy not a reference\n  var places_to_return = places_temp.slice(0)\n\n  // Do sorting after .map(), should be faster performance\n  places_to_return.sort(function(a,b){\n    return a.properties.distance - b.properties.distance\n  })\n\n  /* For debugging, make sure every place is sorted in ascending order\n  places_to_return.map((x) => {\n    console.log(\"sorted: \", x.properties.distance)\n  })\n  */\n  return places_to_return\n}\n\n//Function that checks if a place is within a certain distance of user, for check ins\nexport const validate_check_in = (place, currentLocation, threshold = 0.5) => {\n  const placePoint = turf.point(place.geometry.coordinates)\n  const within_distance = turf_distance(currentLocation, placePoint) < threshold ? true:false\n  return within_distance\n}\n// Function determines if a point falls into the specific boundaries of Jack London District\nexport const in_jls = (currentLocation) => {\n\n  // Hand drawn locations. Roughly everything beneath 7th St, between Market St. and Fallon St.\n  const bounds_jls = turf.polygon([[\n    [-122.282617, 37.802862],\n    [-122.264300, 37.795721],\n    [-122.265502, 37.787005],\n    [-122.288139, 37.796077],\n    [-122.282617, 37.802862]\n  ]])\n  return turf_boolean(currentLocation, bounds_jls)\n}\n\n// Primary function that returns a list of neighborhoods the location is in.\n// The input is the place's properties, returns array of neighborhood id's\n// Vectorizes our wordpress neighborhoods data (neighborhoods.json) and flexibly utilizes available information as bounds\n// If no bounds (bbox) is given, use radius, if no radius, then a hard radius of 0.8 km is set\nexport const in_neighborhood = (place) => {\n\n  // Name array is not returned but could be if desired, more for debugging\n  const valid_neighborhoods_id = []\n  const valid_neighborhoods_name = []\n  const turf_point = turf.point(place.geometry.coordinates)\n\n  neighborhoods.map((neighborhood) => {\n    const neigh_dist = turf_distance([neighborhood.map.lng, neighborhood.map.lat], turf_point)\n\n    /* Use helper function since can't assign turf.boolean() to non valid polygons which in turn can't be handled within\n     the conditional statement*/\n    if (neigh_dist < 5 && in_bbox_helper(place.geometry.coordinates, neighborhood.boundary)){\n      valid_neighborhoods_id.push(neighborhood.id)\n      valid_neighborhoods_name.push(neighborhood.slug)\n    } else if (neighborhood.radius>0.00001 && neigh_dist < neighborhood.radius) {\n      console.log(\"radius checked\")\n      valid_neighborhoods_id.push(neighborhood.id)\n      valid_neighborhoods_name.push(neighborhood.slug)\n    } else if (neigh_dist < 0.8){\n      console.log(\"dist checked\")\n      valid_neighborhoods_id.push(neighborhood.id)\n      valid_neighborhoods_name.push(neighborhood.slug)\n    } else {\n\n    }\n  })\n  return valid_neighborhoods_id\n}\n\n// Helper function to determine if a location is within certain bounds\nexport const in_bbox_helper = (point, bbox) => {\n  if (bbox !== \"\" && bbox !== undefined) {\n    const parsed_bbox = JSON.parse(bbox)\n    const bounds = turf.polygon([parsed_bbox])\n    //console.log(\"bbox\", parsed_bbox)\n    return turf_boolean(point, bounds)\n  } else {\n    //console.log(\"no bbox\")\n    return false\n  }\n}\n\n// General function to find nearest neighborhood of a locations. Returns top ten options\n// Input must be [longitude, lattitude] coordinates\nexport const nearest_neighborhood = (placePoint) => {\n  const neighborhoods_ordered = neighborhoods.map((neighborhood) => {\n    return {\n      name: neighborhood.name,\n      neigh_dist: turf_distance([neighborhood.map.lng, neighborhood.map.lat], placePoint)\n    }\n  })\n  neighborhoods_ordered.sort(function(a,b){\n    return a.neigh_dist - b.neigh_dist\n  })\n  return neighborhoods_ordered.slice(0,10)\n}\n\n// Helper function for associate_badge. Returns every neighborhood challenge badge\n// TODO modify such that inputs can be multiple badge types, for example lookup general badges or neighborhood or place etc.\nexport const challenge_badges_lookup = () => {\n  const challenge_badges = []\n  badges.badges.map((badge) => {\n    if (badge.type == \"neighborhood\") {\n      challenge_badges.push(badge)\n    }\n  })\n  return challenge_badges\n}\n\n// Returns array of valid badges (and properties) that a place is associated with. Give points towards that badge\nexport const associate_badge = (locations) => {\n  const badges_to_check = challenge_badges_lookup()\n  const win_badges = []\n  badges_to_check.map((badge) => {\n    console.log(badge)\n    for (let i = 0; i < locations.length; i++) {\n      if (badge.location.ID == locations[i]) {\n        win_badges.push(badge)\n      }\n    }\n  })\n  return win_badges\n}\n\n/**\n * Gets related vibes for a neighborhood and sorts neighborhoods\n * by vibe intersection count between related and neighborhood vibes.\n *\n * @param {Object[]} neighborhoods\n * @param {String[]} vibeSlugs\n *\n * @returns {Object[]}\n */\nexport const sortNeighborhoodsByVibes = (neighborhoods, vibeSlugs) => {\n  if (vibeSlugs.length === 0) return neighborhoods\n\n  const relatedVibeSlugs = getRelatedVibes(vibeSlugs)\n  const vibeSlugsToIntersect = [...new Set([...vibeSlugs, ...relatedVibeSlugs])]\n\n  // add vibeIntersection property\n  const neighborhoodsWithVibeIntersection = neighborhoods.map(\n    (neighborhood) => {\n      const neighborhoodVibes = neighborhood.vibes || neighborhood.acf.vibes\n      const neighborhoodVibeSlugs = neighborhoodVibes.map(({ slug }) => slug)\n\n      const vibeIntersection = vibeSlugsToIntersect.filter((slug) =>\n        neighborhoodVibeSlugs.includes(slug)\n      ).length\n\n      return {\n        ...neighborhood,\n        vibeIntersection\n      }\n    }\n  )\n\n  const sortedNeighborhoods = neighborhoodsWithVibeIntersection.sort((a, b) =>\n    b.vibeIntersection - a.vibeIntersection\n  )\n\n  // remove vibeIntersection property (just to not alter previous structure)\n  return sortedNeighborhoods.map((neighborhood) => {\n    const { vibeIntersection, ...restOfNeighborhood } = neighborhood\n    return restOfNeighborhood\n  })\n}\n"],"names":["axiosRetry","Axios","retries","retryDelay","exponentialDelay","dayjs","extend","isBetween","utc","dayjsRecur","wordpress","require","activityCategories","ApiUrl","filterList","list","test","value","searchTerm","key","re","RegExp","replace","filter","item","result","isMatch","getRandomItem","Math","floor","random","length","encodeCardIndex","row","column","matchLists","listA","listB","let","matches","includes","word","rankVibes","rankings","map","score","indexOf","reduce","a","b","sortByKey","console","log","sortByPopularity","parseInt","details","msv","sortByArray","sortedList","sortingArr","sort","isClosedToday","dailyHours","opens","closes","displayHours","hours","dayFormat","openHours","isOpen","weeklyHours","find","day_of_week","openEveryday","times","time","format","popularFound","push","day","name","i","orderedHours","dayFound","isClosed","undefined","closed","Object","assign","split","hour","minute","date","openNow","openToday","isPopular","hasDailyHours","daysClosed","getCardOptions","categoryQuery","distanceQuery","geoQuery","searchQuery","vibeQuery","block","singCards","posts","overrideQuery","vibe","cities","selectedCity","slug","location","distance","firstCity","vibesFromCategories","category","point","longitude","latitude","ordering","search","vibes","getAPIParams","options","per_page","activity","params","distanceInMeters","round","constants.METERS_PER_MILE","getCategoryMatch","categories","all_categories","getFullLink","link","type","parse_url","url","parse","URL","path","instagram","twitter","facebook","geLocationFromCity","city","cityDetails","placemarker","getMax","items","attribute","max","forEach","getMin","min","getTimeOfDay","isValid","currentHour","parseFloat","getTopVibes","top_vibes","places","place","properties","hasOwnProperty","sortable","getTopCategories","top_categories","getWaveFromVibe","graphToEvents","edges","edge","groupEvent","node","groupDetails","description","image","images","original","price","recurrence","recurring","which","startTime","endTime","recurRule","nextDateFromRecurring","nextStartTime","next","toLocaleString","nextEndTime","id","title","geometry","coordinates","dateTime","address","streetAddress","is_online","hotspots_place","start_date","end_date","vibemap_images","likes","recurs","groupsToEvents","groups","acf","label","start_time","end_time","toISOString","normalize","val","normalize_all","scale_low","scale_high","scale","LinearScale","domain","range","scaleIconSize","scaleMarker","zoom","isNaN","marker_scale","base_marker","max_marker","scaleDensityArea","density","area","density_scale","scaleDensityBonus","inverted_scale","constants.HEATMAP_INTENSITY","HEATMAP_INTENSITY","relative_density","scaleScore","scaleSelectedMarker","getEventOptions","date_range","today","dayOfWeek","startOf","startOffset","endOffset","monthEnd","endOf","diff","date_range_start","add","date_range_end","fetchEvents","async","activitySearch","days","centerPoint","currentLocation","getLocationFromPoint","nearestCities","sortLocations","module","exports","query","querystring","stringify","apiEndpoint","source","CancelToken","response","get","cancelToken","token","catch","error","statusText","data","count","loading","timedOut","getGroups","recurringGroupEvents","results","features","concat","whichDay","weekOfMonth","recur","every","daysOfWeek","weeksOfMonthByDay","fetchPlacesDetails","fetchPlacePicks","preferredVibes","relatedVibes","numOfPlaces","hasVibes","distanceBetweenLocations","centerpoint","join","getPlaces","newOptions","formatPlaces","vibesQuery","vibesCombined","scorePlaces","decodePlaces","feature","JSON","subcategories","thumbnail_url","opening_hours","tips","telephone","website","fields","place_type","short_name","truncate","constants.TRUCATE_LENGTH","aggregate_rating","num_vibes","sub_categories","top_vibe","matchingCategories","toLowerCase","sortedCategories","icon","cluster","vibesFromPlaces","getRecommendedVibes","scoreBy","shuffle","maxScores","minScores","field","Infinity","zoom_to_use","zoom_norm","weights","exp","rating","offers","placesScored","stats","vibeMatches","vibeBonus","vibes_score","scoreVibeLength","log10","vibeMatchScore","vibeOrderScore","categoryMatches","categories_score","concatCategories","allCategories","index","categoryVibes","foundCategories","constants.place_sub_categories","o","main_category","foundSubcategories","placePoint","turf","turf_distance","offers_score","hours_score","open_now","popular_now","maxAverageScore","minAverageScore","placesScoredAveraged","likes_score","aggregate_rating_score","maxDistance","distance_score","reasons","scores","largestIndex","apply","average_score","reason","placesScoredAndSorted","placesSortedAndNormalized","icon_size","numPlaces","shuffleTopPicks","reducePlaceProperties","fromEntries","numTop","topPlaces","slice","remainingPlaces","toTitleCase","str","charAt","toUpperCase","nearest_places","radius","places_temp","places_to_return","validate_check_in","threshold","in_jls","bounds_jls","polygon","turf_boolean","in_neighborhood","valid_neighborhoods_id","valid_neighborhoods_name","turf_point","neighborhoods","neigh_dist","neighborhood","lng","lat","in_bbox_helper","boundary","bbox","parsed_bbox","bounds","nearest_neighborhood","neighborhoods_ordered","challenge_badges_lookup","challenge_badges","badges","badge","associate_badge","badges_to_check","win_badges","locations","ID","sortNeighborhoodsByVibes","vibeSlugs","relatedVibeSlugs","getRelatedVibes","vibeSlugsToIntersect","Set","neighborhoodsWithVibeIntersection","neighborhoodVibes","neighborhoodVibeSlugs","vibeIntersection","sortedNeighborhoods","restOfNeighborhood"],"mappings":"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"}