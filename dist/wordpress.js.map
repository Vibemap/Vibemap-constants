{"version":3,"file":"wordpress.js","sources":["../utils/wordpress.js"],"sourcesContent":["import Axios from \"axios\"\nimport axiosRetry from 'axios-retry'\n\naxiosRetry(Axios, {\n  retries: 3,\n  retryDelay: axiosRetry.exponentialDelay\n})\n\nconst jsonpack = require('jsonpack')\n\nconst GATSBY_WP_BASEURL = 'https://cms.vibemap.com'\nconst REST_PATH = '/wp-json/wp/v2/'\n\nimport cities from '../dist/cities.json'\nconst helpers = require('./helpers.js')\n\n// Cached Wordpress taxonomies for reference\n// Note: this data is stored everytime this library is versioned.\nconst postCategories = require('../dist/postCategories')\n\nlet vibeTaxonomy = []\nlet activityCategories = []\n\ntry {\n  const vibeTaxonomyPacked = require('../dist/vibesFromCMSTaxonomy.zip.json')\n  vibeTaxonomy = jsonpack.unpack(vibeTaxonomyPacked)\n} catch (error) {\n  console.log('Error with packed vibes ', error)\n}\n\ntry {\n  const activityCategoriesPacked = require('../dist/activityCategories.zip.json')\n  activityCategories = jsonpack.unpack(activityCategoriesPacked)\n} catch (error) {\n  console.log('Error with packed activityCategories ', error)\n}\n\nconst defaultFilters = {\n  categories: [],\n  cities: [],\n  vibesets: [],\n  vibes: []\n}\n\n// Get a list of Wordpress taxonomy or category ids by slug\n// If empty, i.e. the slug isn't use, returns an empty array,\n// which will search for everything.\nexport const getTaxonomyIds = (type, filter = ['chill']) => {\n  switch (type) {\n    case 'category':\n      return filter.map(slug => {\n        // Find taxonomy that match slug\n        const matches = helpers.filterList(activityCategories, slug, 'slug');\n        return matches.length > 0\n          ? matches.map(match => match.id)\n          : []\n      })\n\n    case 'vibe':\n      return filter.map(slug => {\n        // Find taxonomy that match slug\n        const matches = helpers.filterList(vibeTaxonomy, slug, 'slug')\n        return matches.length > 0\n          ? matches.map(match => match.id)\n          : []\n      })\n      break;\n\n    case 'cities':\n      return filter.map(slug => {\n        // Find taxonomy that match slug\n        const matches = helpers.filterList(cities, slug, 'slug')\n\n        const found_id = matches.map(match => match && match.id_wordpress ? match.id_wordpress : match.id)\n\n        return matches.length > 0\n          ? found_id\n          : []\n\n      })\n      break;\n\n    default:\n      break;\n  }\n  return []\n}\n\nexport const fetchBadges = async () => {\n  // const cityFilters = '?_fields=id, link, name, slug, title, acf'\n\n  const endpoint = `${GATSBY_WP_BASEURL + REST_PATH}badges`\n  const response = await Axios.get(endpoint)\n    .catch(error => console.error(error))\n\n  return response\n}\n\nexport const fetchCities = async (per_page = 50) => {\n  const cityFilters = `?_fields=id, link, name, radius, slug, title, acf, type\n    &per_page=${per_page}`\n\n  const endpoint = `${GATSBY_WP_BASEURL + REST_PATH}city${cityFilters}`\n  const response = await Axios.get(endpoint)\n    .catch(error => console.error(error))\n\n  return response\n}\n\n// TODO: Sort by location\n// TODO: SOrt by vibe match\nexport const fetchNeighborhoods = async (filters = defaultFilters, page = 1, postsPerPage = 100) => {\n  //console.log('fetchNeighborhoods: ', filters)\n  // TODO: Filter by vibe or other attributes\n  const source = Axios.CancelToken.source()\n  //console.log('Filtering neighborhoods by: ', filters)\n\n  // TODO: Use the ACF endpoint instead:\n  // https://cms.vibemap.com/wp-json/acf/v3/neighborhoods\n  const fields = ['id', 'slug', 'type', 'link', '_links', 'title', 'categories', 'vibe', 'acf', 'featured_media', 'featured_media_src_url']\n  const apiFilters = `?_fields=${fields.join(',')}`\n  const path = `wp-json/wp/v2/neighborhoods`\n  const random = Math.random()\n  const url = `${GATSBY_WP_BASEURL}/${path}${apiFilters}&refresh=${random}`\n  console.log('Wordpress URL ', url)\n\n  let response = await Axios.get(url, {\n    cancelToken: source.token,\n    params: {\n      _embed: false,\n      fields: fields.join(','),\n      per_page: postsPerPage,\n      page: page >= 1 ? page : 1,\n      //before: buildTime, // Let's make sure posts that have a page built are the only ones being pulled in.\n      categories: filters.category,\n      vibesets: filters.vibesets.toString(),\n      //vibe: 1073, //TODO: Filter by vibe taxonomy\n      //cities: getTaxonomyIds('cities', filters.cities).toString(),\n      //cities: filters.cities.toString(),\n    },\n  })\n    .catch(error => {\n      console.error(error)\n    })\n\n  response.numPages = parseInt(response.headers[\"x-wp-totalpages\"])\n\n  return response\n}\n\n// Get post categories\nexport const fetchActivityCategories = async (\n  filters = defaultFilters,\n  page = 1,\n  per_page = 100,\n  postsPerPage = 500\n) => {\n  const fetchData = async (page = 1, per_page = 100) => {\n    // Fetch all activity categories and subcategories\n    const source = Axios.CancelToken.source()\n    const rest_slug = 'activity-category'\n    const random = Math.random()\n    const rest_url = `${GATSBY_WP_BASEURL}/wp-json/wp/v2/${rest_slug}?per_page=${per_page}&page=${page}&refresh=${random}`\n    console.log(`Fetching ${rest_slug} from ${rest_url}`)\n    let response = await Axios.get(rest_url, { cancelToken: source.token })\n      .catch(error => { console.error(error) })\n\n    return response.data\n  }\n\n  let combinedData = await fetchData(page, per_page);\n\n  let hasNext = true;\n  let nextData = [];\n  let next_page = page;\n  // Handle pagination\n  console.log(`Has more?  `, combinedData.length, next_page * per_page);\n  while (hasNext) {\n    if (combinedData.length >= (next_page * per_page)) {\n      next_page = next_page + 1;\n      nextData = await fetchData(next_page)\n        .catch(error => console.error(error));\n\n      combinedData = combinedData.concat(nextData);\n      //console.log('Updated combinedData ', combinedData.length, nextData.length)\n    } else {\n      hasNext = false;\n    }\n  }\n\n  console.log('Got this many activities: ', combinedData.length)\n  return combinedData\n}\n\n// Get post categories\nexport const fetchCategories = async (\n  filters = defaultFilters,\n  page = 1,\n  postsPerPage = 100\n) => {\n  //console.log('fetchNeighborhoods: ', filters)\n\n  // TODO: Filter by vibe or other attributes\n  const source = Axios.CancelToken.source()\n\n  let response = await Axios.get(`${GATSBY_WP_BASEURL}/wp-json/wp/v2/categories/`, {\n    cancelToken: source.token,\n  })\n    .catch(error => {\n      console.error(error)\n    })\n\n  response.numPages = parseInt(response.headers[\"x-wp-totalpages\"])\n\n  return response\n}\n\nexport const getCityInfo = (name = 'San Francisco', slug = null) => {\n  let city = null\n  if (slug) {\n    // Handle both string and array\n    slug = slug.toString()\n    // Filter cities in wordpress\n    const findCitySlug = cities.filter(result => result.slug === slug.toString())\n    city = findCitySlug.length > 0 ? findCitySlug[0] : null\n  } {\n    const findCityName = cities.filter(result => result.name === name)\n    city = findCityName.length > 0 ? findCityName[0] : null\n  }\n\n  return city\n}\n\nexport const filterNeighborhoods = (neighborhoods, city = 'San Francisco', slug = null) => {\n  // Look up city by slug\n  if (slug) {\n    // Handle both string and array\n    slug = slug.toString()\n    // Filter cities in wordpress\n    const findCitySlug = cities.filter(result => result.slug === slug.toString())\n    city = findCitySlug.length > 0 ? findCitySlug[0].title.rendered : null\n  }\n\n  // Template of the array objects\n  // return {\n  //   id: neighborhood.id,\n  //   title: neighborhood.title.rendered,\n  //   subtitle: 'Neighborhood',\n  //   imageUrl: image,\n  //   url: neighborhood.link.replace(/^(?:\\/\\/|[^/]+)*/, ''),\n  //   slug: neighborhood.slug,\n  //   city: neighborhood.acf.map.city,\n  // };\n  const filterPredicate = (neighborhood) => neighborhood.city === city || neighborhood.title.includes(city)\n\n  // Return all, if there's not city filter\n  if (city || slug) {\n    return filter(neighborhoods, filterPredicate)\n  } else {\n    return neighborhoods\n  }\n}\n\nexport const fetchVibeTaxonomy = async (\n  page = 1,\n  per_page = 100,\n  fields = ['acf', 'id', 'link', 'name', 'slug', 'description'],\n  clearCache = true\n) => {\n\n  const fetchData = async (page = 1, per_page = 100) => {\n    const date = new Date()\n    const taxonomyFilters = `?_fields=${fields.join(',')}&per_page=${per_page}&page=${page}`;\n    const endpoint = `${GATSBY_WP_BASEURL + REST_PATH}vibe${taxonomyFilters}${clearCache ? '&' + date.toISOString() : ''}`;\n    //console.log('fetchVibeTaxonomy ', endpoint)\n    const response = await Axios.get(endpoint)\n      .catch(error => console.error(error))\n\n    return response.data\n  }\n\n  let combinedData = await fetchData(page, per_page)\n\n  let hasNext = true\n  let nextData = []\n  let next_page = page\n  // Check for next page, else return combined\n  while (hasNext) {\n    //console.log('Really has next? ', combinedData.length, (next_page * per_page))\n    if (combinedData.length >= (next_page * per_page)) {\n      next_page = next_page + 1\n      nextData = await fetchData(next_page)\n        .catch(error => console.error(error))\n\n      combinedData = combinedData.concat(nextData)\n      //console.log('Updated combinedData ', combinedData.length, nextData.length)\n    } else {\n      hasNext = false\n    }\n  }\n  //console.log('return combinedData ', combinedData)\n  return combinedData\n}\n\nexport const getGroups = async ({\n  eventsOnly = false,\n  city = null,\n  per_page = 100,\n  search = '',\n} = {}) => {\n\n  /* TODO: GraphQL is too slow\n  const query = {\n    \"operationName\": \"GroupEvents\",\n    \"query\": `query GroupEvents($search: String!) {\n      groups(where: {\n        search: $search\n      }) {\n        edges {\n          node {\n            id: databaseId\n            slug\n            title\n            groupDetails {\n              city {\n                ...on City {\n                  slug\n                }\n              }\n              day\n              description\n              image: icon {\n                mediaItemUrl\n              }\n              isActive\n              hasEvents\n              hasLocation\n              link\n              numMembers\n              recurring\n              recurrence\n              which\n              startTime\n              endTime\n              price\n              rewards\n              vibes {\n                slug\n              }\n              name\n              map {\n                latitude\n                longitude\n                streetAddress\n              }\n            }\n          }\n        }\n      }\n    }\n    `,\n    \"variables\": {\n      search: search\n    }\n  }\n\n  const response = await Axios({\n    url: 'https://cms.vibemap.com/graphql',\n    method: 'post',\n    data: query\n  }).catch((error) => {\n    console.log(`Error fetching events `, error.response)\n    return {\n      error: true,\n      data: {\n        data: []\n      },\n      message: error\n    }\n  })\n\n  const data = response.data\n    && response.data.data\n    && response.data.data.groups\n    && response.data.data.groups.edges\n  */\n  const filters = `?_fields=id,date,slug,title,acf&per_page=${per_page}`\n\n  const endpoint = `${GATSBY_WP_BASEURL + REST_PATH}group${filters}`\n  const response = await Axios.get(endpoint)\n    .catch(error => {\n      console.error(error.response.statusText)\n      return {\n        error: true,\n        data: {\n          data: []\n        },\n        message: error\n      }\n    })\n\n  const data = response.data\n\n  const dataByCity = data && typeof (data) === 'object'\n    ? data.filter(group => {\n      if (group.acf.map && city) {\n        const isMatch = city == group.acf.map.city\n        return isMatch\n      } else {\n        // Return everyting if there's no cit\n        group.title = group.title.rendered;\n        return true\n      }\n    })\n    : []\n\n  if (dataByCity) {\n    return {\n      error: false,\n      data: dataByCity,\n      message: `Got ${dataByCity.length} groups`\n    }\n  } else {\n    return {\n      error: true,\n      data: [],\n      message: `No data for groups`\n    }\n  }\n}\n\nexport const getPosts = async (\n  //args\n  filters = defaultFilters,\n  stickyOnly = false,\n  per_page = 20,\n  fields = [\n    'id',\n    'date',\n    'slug',\n    'status',\n    'type',\n    'link',\n    'title',\n    'content',\n    'excerpt',\n    'author',\n    'categories',\n    'vibe',\n    'blocks',\n    'acf',\n    'featured_media',\n    'featured_media_src_url',\n  ],\n  embed = false,\n  clearCache = false\n) => {\n  const embedParameter = embed ? '&_embed' : ''\n  const apiFilters = `?_fields=${fields.join(',')}`\n  const date = new Date()\n  const endpoint = `${GATSBY_WP_BASEURL}${REST_PATH}posts${apiFilters}${embedParameter}${clearCache ? '&' + date.toISOString() : ''}`\n\n  // Sticky posts to be shown first\n  // TODO: Filter by the vibe or just score by it?\n  const paramsOverride = {\n    per_page: per_page,\n    cities: getTaxonomyIds('cities', filters.cities).toString(),\n    sticky: true\n  }\n\n  if (filters.category && filters.category.length > 0) {\n    paramsOverride.category = getTaxonomyIds('category', filters.category).toString()\n  }\n\n  if (filters.vibes && filters.vibes.length > 0) {\n    // TODO: User a more strict vibe search in some cases\n    // paramsOverride.vibe = getTaxonomyIds('vibe', filters.vibes).toString()\n    paramsOverride.search = filters.vibes.join(', ')\n  }\n\n  let top_posts = await Axios.get(endpoint, {\n    params: paramsOverride,\n  }).catch((error) => {\n    console.error(`Wordpress error`, error)\n  })\n\n  paramsOverride.sticky = false\n\n  console.log('getPosts endpoint', endpoint, paramsOverride)\n\n  let recent_posts = await Axios.get(endpoint, {\n    params: paramsOverride,\n  }).catch((error) => console.error(error))\n\n  // TODO: Sort by vibe match\n  const excludeHiddenPosts = recent_posts.data\n    .filter((post) => post.acf.hide_post !== true)\n    .map((post) => {\n      // Look up display category in cached taxonomy\n      const findCategory = postCategories.filter(\n        (category) => category.id === post.categories[0]\n      );\n      post.category = findCategory ? findCategory[0].name : 'Guide'\n\n      return post\n    })\n\n  // Only sticky posts\n  if (stickyOnly === true) {\n    return top_posts\n  }\n\n  // Put stick posts on top\n  recent_posts.data = recent_posts\n    ? top_posts.data.concat(excludeHiddenPosts)\n    : top_posts\n\n  return recent_posts\n}\n\nexport const getPost = async (id) => {\n  const query = {\n    \"operationName\": \"PostDetails\",\n    \"query\": `query PostDetails($id: String!) {\n      posts {\n        nodes {\n          id\n          slug\n        }\n      }\n    }\n    `,\n    \"variables\": { id: id }\n  }\n  Axios({\n    url: 'https://cms.vibemap.com/graphql',\n    method: 'post',\n    data: query\n  }).then((result) => {\n    console.log(result.data)\n  });\n}\n"],"names":["axiosRetry","Axios","retries","retryDelay","exponentialDelay","jsonpack","require","GATSBY_WP_BASEURL","REST_PATH","helpers","postCategories","let","vibeTaxonomy","activityCategories","vibeTaxonomyPacked","unpack","error","console","log","activityCategoriesPacked","defaultFilters","categories","cities","vibesets","vibes","getTaxonomyIds","type","filter","map","slug","matches","filterList","length","match","id","found_id","id_wordpress","fetchBadges","async","endpoint","get","catch","fetchCities","per_page","cityFilters","fetchNeighborhoods","filters","page","postsPerPage","source","CancelToken","fields","apiFilters","join","random","Math","url","response","cancelToken","token","params","_embed","category","toString","numPages","parseInt","headers","fetchActivityCategories","fetchData","rest_slug","rest_url","data","combinedData","hasNext","nextData","next_page","concat","fetchCategories","getCityInfo","name","city","findCitySlug","result","findCityName","filterNeighborhoods","neighborhoods","title","rendered","neighborhood","includes","fetchVibeTaxonomy","clearCache","date","Date","taxonomyFilters","toISOString","getGroups","statusText","message","dataByCity","group","acf","getPosts","stickyOnly","embed","embedParameter","paramsOverride","sticky","search","top_posts","recent_posts","excludeHiddenPosts","post","hide_post","findCategory","getPost","method","operationName","query","variables","then"],"mappings":"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"}