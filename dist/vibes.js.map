{"version":3,"file":"vibes.js","sources":["../utils/vibes.js"],"sourcesContent":["import Fuse from 'fuse.js'\nimport LinearScale from 'linear-scale'\nconst jsonpack = require('jsonpack')\n\nimport allActivities from '../dist/activityCategories.json'\n\nlet activityCategories = {}\nlet allVibes = []\nlet vibeRelations = []\n\ntry {\n    // Unpack compressed vibes data\n    const vibeTaxonomyPacked = require('../dist/vibesFromCMSTaxonomy.zip.json')\n    allVibes = jsonpack.unpack(vibeTaxonomyPacked)\n\n    const vibeRelationsPacked = require('../dist/vibeRelations.zip.json')\n    vibeRelations = jsonpack.unpack(vibeRelationsPacked)\n\n    activityCategories = allActivities.activityCategories\n\n} catch (error) {\n    console.log('Error upacking vibes ', error)\n}\n\n\n// TODO: Import as token var, not all objects\nimport * as style_variables from '../design-system/build/json/variables.json';\n\n// Get vibe attributes\nexport const getVibeInfo = (vibe = 'chill') => {\n\n    const vibeInfo = allVibes.find((item) => item.slug === vibe)\n\n    if (vibeInfo) {\n        return vibeInfo\n    } else {\n        return null\n    }\n}\n\nexport const getVibesFromSlugs = (slugs) => {\n    const vibes = []\n\n    slugs.forEach(slug => {\n        const foundVibe = allVibes.find(vibe => vibe.slug === slug)\n        if (foundVibe) vibes.push(foundVibe)\n    })\n\n    return vibes\n}\n\nexport const getVibeGradient = (vibe = 'chill') => {\n    let color1 = '#DDDDDD'\n    let color2 = '#AAAAAA'\n\n    const vibe_styles = style_variables['default']['color']['vibes']\n    const vibeInfo = allVibes.filter(item => vibe === item.key)\n\n    const vibeColors = vibe_styles[vibe]\n\n    if (vibe_styles[vibe]) {\n        color1 = vibeColors['primary']\n        color2 = vibeColors['secondary']\n    }\n\n    const colorInfo = {\n        color1: color1,\n        color2: color2,\n        gradient: `linear-gradient(44deg, ${color1} 20%, ${color2} 100% )`,\n    }\n\n    return colorInfo\n}\n\nexport const getCategory = (slug = 'food') => {\n    const category = activityCategories.find(item => item.slug === slug)\n\n    if (category) {\n        return category\n    } else {\n        return null\n    }\n}\n\nexport const getCategoriesByLevel = (level = 2) => {\n    const categoriesByLevel = activityCategories.filter(category => {\n        const isMatch = parseInt(category.level) == level\n        return isMatch\n    })\n\n    return categoriesByLevel\n}\n\nexport const flattenCategories = (categories, level = 1) => {\n    let result = []\n\n    categories.forEach((category) => {\n        const { subcategories, ...restOfCategory } = category\n        result.push(restOfCategory)\n        if (level > 1 && subcategories && subcategories.length > 0) {\n            result = [\n                ...result,\n                ...flattenCategories(subcategories, level - 1)\n            ]\n        }\n    })\n\n    return result\n}\n\nexport const activityCategoryToOptions = (activities) => {\n    //console.log('activitiesToOptions ', activities)\n    const activityOptions = activities.map(item => {\n        // TODO: Overwrite title with focus keyword, when present\n        const seoTitle = item.seo && item.seo.focuskw && item.seo.focuskw.length > 0\n            ? item.seo.focuskw\n            : item && item.title ? item.title : item.name\n\n        const option = {\n            key: item.slug,\n            label: seoTitle,\n            seo: item.seo,\n            title: item.name,\n            value: item.slug,\n            level: item.level\n        }\n\n        return option\n    })\n\n    return activityOptions\n}\n\nexport const getSubCategories = (category = 'all', format = 'all') => {\n    const categories = activityCategories\n    const sub_category = categories.find(item => item.slug === category)\n    const sub_categories = sub_category.details.sub_categories\n\n    let subCategoriesExport = []\n    switch (format) {\n        case 'keys':\n            subCategoriesExport = sub_categories.map(item => item.slug)\n            break;\n\n        case 'all':\n            // TODO: get details for each sub catgory\n            subCategoriesExport = sub_categories.map(sub_category => getCategory(sub_category.slug))\n            break;\n\n        // Else return all object\n        default:\n            subCategoriesExport = sub_categories\n            break;\n    }\n\n    return subCategoriesExport\n}\n\n\n// Print all vibes\nexport const getVibes = (format = 'keys') => {\n\n    let all = []\n\n    switch (format) {\n        case 'keys':\n            all = allVibes.map(vibe => vibe.slug)\n            break;\n\n        case 'all':\n            all = allVibes\n            break;\n\n        // Else return all object\n        default:\n            all = allVibes\n            break;\n    }\n\n    //console.log('getVibes ', all)\n    return all\n}\n\nexport const searchCategories = (vibe = 'ing', threshold = 0.2, fields_to_search = ['name', 'definition', 'title']) => {\n    const options = {\n        //distance: 10,\n        includeScore: true,\n        keys: fields_to_search,\n        threshold: threshold,\n    }\n\n    const fuseVibes = new Fuse(activityCategories, options)\n    const results = fuseVibes.search(vibe)\n\n    return results\n}\n\nexport const searchVibes = (vibe = 'ing', threshold = 0.2, fields_to_search = ['name', 'definition']) => {\n    const options = {\n        //distance: 10,\n        includeScore: true,\n        keys: fields_to_search,\n        threshold: threshold,\n    }\n\n    const fuseVibes = new Fuse(allVibes, options)\n    const results = fuseVibes.search(vibe)\n\n    return results\n}\n\n\n/**\n * getVibePreferences\n * Gets a matrix or list (see returnFormat param) * of preferred vibes for the\n * user's profile\n *\n * @typedef {Object} VibeCheck\n * @property {String[]} vibes\n *\n * @typedef {Object} VibePointEvent\n * @property {'search vibes'|'vibe check'|'vibe'|'check-in'} reason\n * @property {String?} searchVibes\n * @property {String[][]?} vibeCheckVibe\n *\n * @typedef {Object} ExtraData\n * @property {Object<String, Object>} favorites\n * @property {String[]} myVibes\n * @property {VibePointEvent[]} vibePoints\n * @property {Object<String, Object>} upvotedVibes\n * @property {VibeCheck[]} vibeCheckHistory\n *\n * @typedef {Object} Profile\n * @property {ExtraData} extra_data\n *\n * @param {'matrix'|'array'} returnFormat\n * @param {Profile} data\n * @param {Number} threshold  sorts out vibes with a score <= threshold\n * @param {Boolean} normalize bind values between 0 and 1?\n */\nexport const getVibePreferences = (\n    // Default to test profile\n    returnFormat = 'matrix',\n    data = null,\n    threshold = 0,\n    normalize = true,\n) => {\n    if (!data || !data.extra_data) {\n        throw new Error('getVibePreferences: the data parameter must have a `extra_data` property')\n    }\n    // this should be imported instead. For testing, hard-coded here\n    const allVibes = getVibes('keys')\n\n    //console.log(allVibes.length)\n    let matrix = allVibes.map(x => 0.0)\n\n    // weights are currently arbitrarily defined. No hard science, editable\n    const weights = {\n        \"favorites\": 1.0,\n        \"myvibes\": 1.0,\n        \"vibepoints\": { \"search\": 0.1, \"vibecheck\": 0.4, \"save\": 0.5 },\n        \"upvotedvibes\": { \"vibenames\": 0.4, \"meta\": 0.2 },\n        \"vibecheckhistory\": 0.7,\n    }\n\n    const extra_data = data.extra_data\n\n    if (extra_data.favorites) {\n        // favorite place's vibes\n        Object.values(extra_data.favorites).forEach((place) => {\n            if (!(place && place.properties && place.properties.vibes)) {\n                return;\n            }\n\n            place.properties.vibes.forEach((vibe) => {\n                if (allVibes.includes(vibe)) {\n                    const index = allVibes.indexOf(vibe)\n                    matrix[index] = matrix[index] + weights.favorites\n                }\n            })\n        })\n    }\n\n\n    if (extra_data.myVibes) {\n        // user's \"my vibes\"\n        extra_data.myVibes.map(function (x) {\n            if (allVibes.includes(x)) {\n                let index = allVibes.indexOf(x)\n                matrix[index] = matrix[index] + weights.myvibes\n            }\n        })\n    }\n\n    if (extra_data.vibePoints) {\n        // should result in 5 absurds\n        // any action resulting in vibepoints, use associated vibes of actions\n        // in future should include \"vibe\" and \"check-in\" as actions, include their vibes as well\n        extra_data.vibePoints.forEach((vibePointEvent) => {\n            switch (vibePointEvent.reason) {\n                case 'search vibes':\n                    vibePointEvent.searchVibes.forEach((searchedVibe) => {\n                        const index = allVibes.indexOf(searchedVibe)\n                        matrix[index] = matrix[index] + weights.vibepoints.search;\n                    })\n                    break\n                case 'vibe check':\n                    if (!vibePointEvent.vibeCheckVibe[0]) return;\n                    vibePointEvent.vibeCheckVibe[0].forEach((vibe) => {\n                        const index = allVibes.indexOf(vibe);\n                        matrix[index] = matrix[index] + weights.vibepoints.vibecheck;\n                    })\n                    break\n                case 'vibe':\n                case 'check-in':\n                default:\n                    break\n            }\n        })\n    }\n\n    if (extra_data.upvotedVibes) {\n        // tally both meta-data of the place where a vibe was upvoted (place's vibes)\n        // as well as the vibes added (upvoted)\n        Object.values(extra_data.upvotedVibes).forEach((upvoted) => {\n            if (!(upvoted && upvoted.place && upvoted.place.properties && upvoted.place.properties.vibes)) {\n                return;\n            }\n\n            const upvotedPlaceVibes = upvoted.place.properties.vibes\n            upvotedPlaceVibes.forEach((vibe) => {\n                if (allVibes.includes(vibe)) {\n                    const index = allVibes.indexOf(vibe)\n                    matrix[index] = matrix[index] + weights.upvotedvibes.meta\n                }\n            })\n            if (!(upvoted && upvoted.vibeNames)) {\n                return;\n            }\n            upvoted.vibeNames.forEach((vibeName) => {\n                if (allVibes.includes(vibeName)) {\n                    const index = allVibes.indexOf(vibeName)\n                    matrix[index] = matrix[index] + weights.upvotedvibes.vibenames\n                }\n            })\n        })\n    }\n\n    if (extra_data.vibeCheckHistory) {\n        // vibecheck vibes are tallied as well\n        extra_data.vibeCheckHistory.forEach((vibeCheck) => {\n            if (!(vibeCheck && vibeCheck.vibes)) {\n                return;\n            }\n\n            vibeCheck.vibes.forEach((vibes) => {\n                vibes.forEach((vibe) => {\n                    if (allVibes.includes(vibe)) {\n                        const index = allVibes.indexOf(vibe)\n                        matrix[index] = matrix[index] + weights.vibecheckhistory\n                    }\n                })\n            })\n        })\n    }\n\n    // used for normalization\n    const maxScore = matrix.reduce((previousValue, score) => {\n        if (score > previousValue) return score;\n        return previousValue;\n    }, 0)\n\n    // normalize and return matrix\n    if (returnFormat === 'matrix') {\n        return normalize && maxScore !== 0\n            ? matrix.map((score) => score / maxScore)\n            : matrix\n    }\n\n    // Join the matrix with vibes\n    const vibesScored = matrix.map((score, i) => {\n        const vibe = allVibes[i]\n\n        return {\n            key: vibe,\n            score: normalize && maxScore !== 0\n                ? score / maxScore\n                : score\n        }\n    })\n\n    // Sort by score in decending order\n    const vibesSorted = vibesScored.sort((a, b) => {\n        return b.score - a.score\n    })\n\n    // Create an object of only vibes with scores\n    const onlyPreferredVibes = vibesSorted.filter(vibe => vibe.score > threshold)\n    return onlyPreferredVibes.map(({ key }) => key)\n}\n\n// Get and sort vibe times\nexport const getVibesFromVibeTimes = (vibeTimes) => {\n    const vibes = (vibeTimes && vibeTimes.length > 0)\n        ? vibeTimes\n            .sort((a, b) => b.score - a.score)\n            .map(vibe => vibe.name)\n        : []\n\n    console.log('Handle these vibe times: ', vibeTimes, vibes)\n\n    return vibes\n}\n\nexport const getRelatedVibes = (vibes = ['chill'], similarity = 0.4) => {\n    let relatedVibes = vibes\n\n    const vibesWithRelated = vibes.flatMap(vibe => {\n        const vibeInfo = getVibeInfo(vibe)\n        let allRelated = []\n\n        if (vibeInfo && vibeInfo.details && vibeInfo.details.vibes) {\n            relatedVibes = relatedVibes.concat(vibeInfo.details.vibes)\n        }\n\n        if (vibeInfo && vibeInfo.alias) {\n            allRelated = relatedVibes.concat([vibeInfo.alias])\n        }\n\n        const similarVibes = vibeRelations[vibe]\n        const mostSimilar = []\n        for (vibe in similarVibes) {\n            //console.log('Check most similar ', similarVibes[vibe], vibe)\n            if (similarVibes[vibe] >= similarity) mostSimilar.push(vibe)\n        }\n\n        allRelated = relatedVibes.concat(mostSimilar)\n        return allRelated\n    })\n\n    // Make it a unqiue set\n    const relatedVibesUnique = [...new Set(vibesWithRelated)]\n\n    return relatedVibesUnique\n}\n\n// Function derived from hand selecting point values for scaling then modeling exponential function for best fit\nexport const yourvibe_scale_v1 = (x) => {\n    let y = 1.061645 * (x ** 0.289052)\n\n    // Return only values such that 0<=y<=1\n    if (y > 1) {\n        y = 1\n        //console.log(\"y rounded down to 1\")\n    } else if (y < 0) {\n        y = 0\n        //console.log(\"y rounded up to 0\")\n    }\n    return y\n}\n\nexport const normalize_all = (\n    val = 500,\n    min = 1,\n    max = 100,\n    scale_low = 1,\n    scale_high = 10\n) => {\n    var lin_scale = LinearScale()\n        .domain([min, max])\n        .range([scale_low, scale_high])\n\n    const normalized = lin_scale(val)\n\n    return normalized\n}\n\n/* Function responsible for returning \"% Your Vibe\" on place page using user inputted vibes (myvibes)\nand a place's vibes (placevibes) as input. vibeRelations is a pre-calculated json of lexical relations between\nvibe words, generated using Google's pre-trained Word2Vec model\n*/\nexport const percent_yourvibe = (myvibes, placevibes) => {\n    let my_vibes_fraction = 1 / myvibes.length\n\n    // Running score of your vibe, default to 0\n    let yourvibe = 0\n\n    // Running list of vibes that have relation, but not perfect matches\n    var related_vibes = []\n\n    // fraction_counter tracks total perfect matches between myvibes and placevibes. Subtract from place vibes for remaining vibes to match\n    let fraction_counter = 0\n    myvibes.map(vibe_m => {\n\n        // If there's a direct match, add fraction of total number of user vibes as score\n        if (placevibes.includes(vibe_m)) {\n            yourvibe += my_vibes_fraction\n            fraction_counter += 1\n            //console.log([vibe_m], my_vibes_fraction, fraction_counter)\n        }\n\n        // So long as vibes exist in matrix (prevent undefined errors), map place vibes and look for match\n        if (vibe_m in vibeRelations) {\n            //console.log([vibe_m])\n\n            placevibes.map((vibe_p) => {\n                // If match, add corresponding cosine similarity score\n                if (vibe_p in vibeRelations[vibe_m]) {\n                    related_vibes.push(vibeRelations[vibe_m][vibe_p])\n                }\n            })\n        }\n    })\n\n    // Count number of vibes remaining in place that are not direct matches\n    let remaining_place_vibes = placevibes.length - fraction_counter\n\n    // If related vibes are found and not-direct matches are more than 1, combine all scores and take log_matches(related_vibes_score)\n    if (related_vibes.length >= 1 && (remaining_place_vibes) > 1) {\n        var related_vibes_score = related_vibes.reduce((a, b) => a + b, 0)\n\n        // Add 1 to prevent any negative values. Can skew data for remaining_place_vibes == 2 or 3 but not significant\n        if (related_vibes_score < 1) {\n            related_vibes_score += 1\n        }\n        // Change of Base, new variable that will be score normalized for remaining gap\n        var remaining_score = Math.log10(10) / Math.log10(20)\n\n        // Avoid Log_1 division by zero/infinite error. Edge Casing\n    } else if (related_vibes.length >= 1 && (remaining_place_vibes) == 1) {\n        var remaining_score = related_vibes[0]\n\n        // No related matches found, score is zero\n    } else {\n        var remaining_score = 0\n    }\n\n    // Scaled remaining portion of potential vibe score, for related not direct vibes\n    let remaining_score_normalized = normalize_all(remaining_score, 0, 1, 0, (my_vibes_fraction * (myvibes.length - fraction_counter)))\n\n    yourvibe += remaining_score_normalized\n    // Round using vibe scaling function. Default all 0 scores (no relation whatsoever) to 0.5 (50%)\n    let yourvibe_rounded = yourvibe_scale_v1(yourvibe)\n    if (yourvibe_rounded <= 0) {\n        yourvibe_rounded = 0.5\n    }\n\n    // Round after multiplying by 100 so not everything is just 1 (0.95 roudns to 1)\n    return Math.round(yourvibe_rounded * 100)\n}"],"names":["jsonpack","require","let","activityCategories","allVibes","vibeRelations","vibeTaxonomyPacked","vibeRelationsPacked","unpack","allActivities","error","console","log","getVibeInfo","vibe","vibeInfo","find","item","slug","getVibesFromSlugs","vibes","slugs","forEach","foundVibe","push","getVibeGradient","color1","color2","vibe_styles","style_variables['default']","vibeColors","filter","key","colorInfo","gradient","getCategory","category","getCategoriesByLevel","level","parseInt","flattenCategories","categories","result","subcategories","restOfCategory","length","activityCategoryToOptions","activities","map","seoTitle","seo","focuskw","title","name","label","value","getSubCategories","format","sub_categories","details","subCategoriesExport","sub_category","getVibes","all","searchCategories","threshold","fields_to_search","options","includeScore","keys","fuseVibes","Fuse","search","searchVibes","getVibePreferences","returnFormat","data","normalize","extra_data","Error","matrix","x","weights","favorites","myvibes","vibepoints","vibecheck","save","upvotedvibes","vibenames","meta","vibecheckhistory","maxScore","Object","values","place","properties","includes","index","indexOf","myVibes","vibePoints","vibePointEvent","reason","searchedVibe","vibeCheckVibe","upvotedVibes","upvoted","upvotedPlaceVibes","vibeNames","vibeName","vibeCheckHistory","vibeCheck","reduce","previousValue","score","vibesScored","i","vibesSorted","sort","a","b","onlyPreferredVibes","getVibesFromVibeTimes","vibeTimes","getRelatedVibes","similarity","relatedVibes","vibesWithRelated","flatMap","allRelated","concat","alias","similarVibes","mostSimilar","Set","yourvibe_scale_v1","y","normalize_all","val","min","max","scale_low","scale_high","LinearScale","domain","range","lin_scale","percent_yourvibe","placevibes","my_vibes_fraction","yourvibe","related_vibes","fraction_counter","vibe_m","vibe_p","remaining_place_vibes","remaining_score_normalized","remaining_score","Math","log10","yourvibe_rounded","round"],"mappings":"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"}