{"version":3,"file":"vibes.js","sources":["../utils/vibes.js"],"sourcesContent":["import LinearScale from 'linear-scale'\nconst jsonpack = require('jsonpack')\n\nlet allVibes = []\nlet vibeRelations = []\n\ntry {\n    // Unpack compressed vibes data\n    const vibeTaxonomyPacked = require('../dist/vibesFromCMSTaxonomy.zip.json')\n    allVibes = jsonpack.unpack(vibeTaxonomyPacked)\n\n    const vibeRelationsPacked = require('../dist/vibeRelations.zip.json')\n    vibeRelations = jsonpack.unpack(vibeRelationsPacked)\n\n} catch (error) {\n    console.log('Error upacking vibes ', error)\n}\n\n\n// TODO: Import as token var, not all objects\nimport * as style_variables from '../design-system/build/json/variables.json';\n\n// Get vibe attributes\nexport const getVibeInfo = (vibe = 'chill') => {\n\n    const vibeInfo = allVibes.find((item) => item.slug === vibe)\n\n    if (vibeInfo) {\n        return vibeInfo\n    } else {\n        return null\n    }\n}\n\nexport const getVibeGradient = (vibe = 'chill') => {\n    let color1 = '#DDDDDD'\n    let color2 = '#AAAAAA'\n\n    const vibe_styles = style_variables['default']['color']['vibes']\n    const vibeInfo = allVibes.filter(item => vibe === item.key)\n\n    const vibeColors = vibe_styles[vibe]\n\n    if (vibe_styles[vibe]) {\n        color1 = vibeColors['primary']\n        color2 = vibeColors['secondary']\n    }\n\n    const colorInfo = {\n      color1: color1,\n      color2: color2,\n      gradient: `linear-gradient(44deg, ${color1} 20%, ${color2} 100% )`,\n    }\n\n    return colorInfo\n}\n\n// Print all vibes\nexport const getVibes = (format = 'keys') => {\n\n    let all = []\n\n    switch (format) {\n        case 'keys':\n            all = allVibes.map(vibe => vibe.slug)\n            break;\n\n        case 'all':\n            all = allVibes\n            break;\n\n        // Else return all object\n        default:\n            all = allVibes\n            break;\n    }\n\n    //console.log('getVibes ', all)\n    return all\n}\n\n\n/**\n * getVibePreferences\n * Gets a matrix or list (see returnFormat param) * of preferred vibes for the\n * user's profile\n *\n * @typedef {Object} VibeCheck\n * @property {String[]} vibes\n *\n * @typedef {Object} VibePointEvent\n * @property {'search vibes'|'vibe check'|'vibe'|'check-in'} reason\n * @property {String?} searchVibes\n * @property {String[][]?} vibeCheckVibe\n *\n * @typedef {Object} ExtraData\n * @property {Object<String, Object>} favorites\n * @property {String[]} myVibes\n * @property {VibePointEvent[]} vibePoints\n * @property {Object<String, Object>} upvotedVibes\n * @property {VibeCheck[]} vibeCheckHistory\n *\n * @typedef {Object} Profile\n * @property {ExtraData} extra_data\n *\n * @param {'matrix'|'array'} returnFormat\n * @param {Profile} data\n * @param {Number} threshold  sorts out vibes with a score <= threshold\n * @param {Boolean} normalize bind values between 0 and 1?\n */\nexport const getVibePreferences = (\n    // Default to test profile\n    returnFormat = 'matrix',\n    data = null,\n    threshold = 0,\n    normalize = true,\n) => {\n    if (!data || !data.extra_data) {\n        throw new Error('getVibePreferences: the data parameter must have a `extra_data` property')\n    }\n    // this should be imported instead. For testing, hard-coded here\n    const allVibes = getVibes('keys')\n\n    //console.log(allVibes.length)\n    let matrix = allVibes.map(x => 0.0)\n\n    // weights are currently arbitrarily defined. No hard science, editable\n    const weights = {\n        \"favorites\": 1.0,\n        \"myvibes\": 1.0,\n        \"vibepoints\": { \"search\": 0.1, \"vibecheck\": 0.4, \"save\": 0.5 },\n        \"upvotedvibes\": { \"vibenames\": 0.4, \"meta\": 0.2 },\n        \"vibecheckhistory\": 0.7,\n    }\n\n    const extra_data = data.extra_data\n\n    if (extra_data.favorites) {\n        // favorite place's vibes\n        Object.values(extra_data.favorites).forEach((place) => {\n            if (!(place && place.properties && place.properties.vibes)) {\n                return;\n            }\n\n            place.properties.vibes.forEach((vibe) => {\n                if (allVibes.includes(vibe)) {\n                    const index = allVibes.indexOf(vibe)\n                    matrix[index] = matrix[index] + weights.favorites\n                }\n            })\n        })\n    }\n\n\n    if (extra_data.myVibes) {\n        // user's \"my vibes\"\n        extra_data.myVibes.map(function (x) {\n            if (allVibes.includes(x)) {\n                let index = allVibes.indexOf(x)\n                matrix[index] = matrix[index] + weights.myvibes\n            }\n        })\n    }\n\n    if (extra_data.vibePoints) {\n        // should result in 5 absurds\n        // any action resulting in vibepoints, use associated vibes of actions\n        // in future should include \"vibe\" and \"check-in\" as actions, include their vibes as well\n        extra_data.vibePoints.forEach((vibePointEvent) => {\n            switch (vibePointEvent.reason) {\n            case 'search vibes':\n                vibePointEvent.searchVibes.forEach((searchedVibe) => {\n                    const index = allVibes.indexOf(searchedVibe)\n                    matrix[index] = matrix[index] + weights.vibepoints.search;\n                })\n                break\n            case 'vibe check':\n                if (!vibePointEvent.vibeCheckVibe[0]) return;\n                vibePointEvent.vibeCheckVibe[0].forEach((vibe) => {\n                    const index = allVibes.indexOf(vibe);\n                    matrix[index] = matrix[index] + weights.vibepoints.vibecheck;\n                })\n                break\n            case 'vibe':\n            case 'check-in':\n            default:\n                break\n            }\n        })\n    }\n\n    if (extra_data.upvotedVibes) {\n        // tally both meta-data of the place where a vibe was upvoted (place's vibes)\n        // as well as the vibes added (upvoted)\n        Object.values(extra_data.upvotedVibes).forEach((upvoted) => {\n            if (!(upvoted && upvoted.place && upvoted.place.properties && upvoted.place.properties.vibes)) {\n                return;\n            }\n\n            const upvotedPlaceVibes = upvoted.place.properties.vibes\n            upvotedPlaceVibes.forEach((vibe) => {\n                if (allVibes.includes(vibe)) {\n                    const index = allVibes.indexOf(vibe)\n                    matrix[index] = matrix[index] + weights.upvotedvibes.meta\n                }\n            })\n            if (!(upvoted && upvoted.vibeNames)) {\n                return;\n            }\n            upvoted.vibeNames.forEach((vibeName) => {\n                if (allVibes.includes(vibeName)) {\n                    const index = allVibes.indexOf(vibeName)\n                    matrix[index] = matrix[index] + weights.upvotedvibes.vibenames\n                }\n            })\n        })\n    }\n\n    if (extra_data.vibeCheckHistory) {\n        // vibecheck vibes are tallied as well\n        extra_data.vibeCheckHistory.forEach((vibeCheck) => {\n            if (!(vibeCheck && vibeCheck.vibes)) {\n                return;\n            }\n\n            vibeCheck.vibes.forEach((vibes) => {\n                vibes.forEach((vibe) => {\n                    if (allVibes.includes(vibe)) {\n                        const index = allVibes.indexOf(vibe)\n                        matrix[index] = matrix[index] + weights.vibecheckhistory\n                    }\n                })\n            })\n        })\n    }\n\n    // used for normalization\n    const maxScore = matrix.reduce((previousValue, score) => {\n        if (score > previousValue) return score;\n        return previousValue;\n    }, 0)\n\n    // normalize and return matrix\n    if (returnFormat === 'matrix') {\n        return normalize && maxScore !== 0\n            ? matrix.map((score) => score / maxScore)\n            : matrix\n    }\n\n    // Join the matrix with vibes\n    const vibesScored = matrix.map((score, i) => {\n        const vibe = allVibes[i]\n\n        return {\n            key: vibe,\n            score: normalize && maxScore !== 0\n                ? score / maxScore\n                : score\n        }\n    })\n\n    // Sort by score in decending order\n    const vibesSorted = vibesScored.sort((a,b) => {\n        return b.score - a.score\n    })\n\n    // Create an object of only vibes with scores\n    const onlyPreferredVibes = vibesSorted.filter(vibe => vibe.score > threshold)\n    return onlyPreferredVibes.map(({ key }) => key)\n}\n\n// Get and sort vibe times\nexport const getVibesFromVibeTimes = (vibeTimes) => {\n    const vibes = (vibeTimes && vibeTimes.length > 0)\n        ? vibeTimes\n            .sort((a,b) => b.score - a.score)\n            .map(vibe => vibe.name)\n        : []\n\n    console.log('Handle these vibe times: ', vibeTimes, vibes)\n\n    return vibes\n}\n\nexport const getRelatedVibes = (vibes = ['chill'], similarity = 0.4) => {\n\tlet relatedVibes = []\n\n    const vibesWithRelated = vibes.flatMap(vibe => {\n\t\tconst vibeInfo = getVibeInfo(vibe)\n\t\tlet allRelated = []\n\n\t\tif (vibeInfo && vibeInfo.related) {\n\t\t\trelatedVibes = relatedVibes.concat(vibeInfo.related)\n\t\t}\n\n\t\tif (vibeInfo && vibeInfo.alias) {\n\t\t\tallRelated = relatedVibes.concat([vibeInfo.alias])\n\t\t}\n\n\t\tconst similarVibes = vibeRelations[vibe]\n\t\tconst mostSimilar = []\n\t\tfor (vibe in similarVibes) {\n\t\t\t//console.log('Check most similar ', similarVibes[vibe], vibe)\n\t\t\tif (similarVibes[vibe] >= similarity) mostSimilar.push(vibe)\n\t\t}\n\n\t\tallRelated = relatedVibes.concat(mostSimilar)\n\t\treturn allRelated\n\t})\n\n\t// Make it a unqiue set\n\tconst relatedVibesUnique = [...new Set(vibesWithRelated)]\n\n    return relatedVibesUnique\n}\n\n// Function derived from hand selecting point values for scaling then modeling exponential function for best fit\nexport const yourvibe_scale_v1 = (x) => {\n    let y = 1.061645 * (x**0.289052)\n\n    // Return only values such that 0<=y<=1\n    if (y>1) {\n        y = 1\n        //console.log(\"y rounded down to 1\")\n    } else if (y<0) {\n        y = 0\n        //console.log(\"y rounded up to 0\")\n    }\n    return y\n}\n\nexport const normalize_all = (\n  val = 500,\n  min = 1,\n  max = 100,\n  scale_low = 1,\n  scale_high = 10\n) => {\n  var lin_scale = LinearScale()\n    .domain([min, max])\n    .range([scale_low, scale_high])\n\n    const normalized = lin_scale(val)\n\n    return normalized\n}\n\n/* Function responsible for returning \"% Your Vibe\" on place page using user inputted vibes (myvibes)\nand a place's vibes (placevibes) as input. vibeRelations is a pre-calculated json of lexical relations between\nvibe words, generated using Google's pre-trained Word2Vec model\n*/\nexport const percent_yourvibe = (myvibes, placevibes) => {\n    let my_vibes_fraction = 1/myvibes.length\n\n    // Running score of your vibe, default to 0\n    let yourvibe = 0\n\n    // Running list of vibes that have relation, but not perfect matches\n    var related_vibes = []\n\n    // fraction_counter tracks total perfect matches between myvibes and placevibes. Subtract from place vibes for remaining vibes to match\n    let fraction_counter = 0\n    myvibes.map(vibe_m => {\n\n        // If there's a direct match, add fraction of total number of user vibes as score\n        if(placevibes.includes(vibe_m)) {\n            yourvibe += my_vibes_fraction\n            fraction_counter += 1\n            //console.log([vibe_m], my_vibes_fraction, fraction_counter)\n        }\n\n        // So long as vibes exist in matrix (prevent undefined errors), map place vibes and look for match\n        if (vibe_m in vibeRelations) {\n          //console.log([vibe_m])\n\n          placevibes.map((vibe_p) => {\n            // If match, add corresponding cosine similarity score\n            if (vibe_p in vibeRelations[vibe_m]) {\n              related_vibes.push(vibeRelations[vibe_m][vibe_p])\n            }\n          })\n        }\n    })\n\n    // Count number of vibes remaining in place that are not direct matches\n    let remaining_place_vibes = placevibes.length - fraction_counter\n\n    // If related vibes are found and not-direct matches are more than 1, combine all scores and take log_matches(related_vibes_score)\n    if (related_vibes.length>=1 && (remaining_place_vibes)>1){\n        var related_vibes_score = related_vibes.reduce((a, b) => a + b, 0)\n\n        // Add 1 to prevent any negative values. Can skew data for remaining_place_vibes == 2 or 3 but not significant\n        if (related_vibes_score < 1) {\n            related_vibes_score += 1\n        }\n        // Change of Base, new variable that will be score normalized for remaining gap\n        var remaining_score = Math.log10(10)/Math.log10(20)\n\n    // Avoid Log_1 division by zero/infinite error. Edge Casing\n    } else if (related_vibes.length>=1 && (remaining_place_vibes)==1){\n        var remaining_score = related_vibes[0]\n\n    // No related matches found, score is zero\n    } else {\n        var remaining_score = 0\n    }\n\n    // Scaled remaining portion of potential vibe score, for related not direct vibes\n    let remaining_score_normalized = normalize_all(remaining_score, 0, 1, 0, (my_vibes_fraction*(myvibes.length-fraction_counter)))\n\n    yourvibe += remaining_score_normalized\n    // Round using vibe scaling function. Default all 0 scores (no relation whatsoever) to 0.5 (50%)\n    let yourvibe_rounded = yourvibe_scale_v1(yourvibe)\n    if (yourvibe_rounded <= 0){\n        yourvibe_rounded = 0.5\n    }\n\n    // Round after multiplying by 100 so not everything is just 1 (0.95 roudns to 1)\n    return Math.round(yourvibe_rounded*100)\n}"],"names":["jsonpack","require","let","allVibes","vibeRelations","vibeTaxonomyPacked","vibeRelationsPacked","unpack","error","console","log","getVibeInfo","vibe","vibeInfo","find","item","slug","getVibeGradient","color1","color2","vibe_styles","style_variables['default']","vibeColors","filter","key","colorInfo","gradient","getVibes","format","all","map","getVibePreferences","returnFormat","data","threshold","normalize","extra_data","Error","matrix","x","weights","favorites","myvibes","vibepoints","search","vibecheck","save","upvotedvibes","vibenames","meta","vibecheckhistory","maxScore","Object","values","forEach","place","properties","vibes","includes","index","indexOf","myVibes","vibePoints","vibePointEvent","reason","searchVibes","searchedVibe","vibeCheckVibe","upvotedVibes","upvoted","upvotedPlaceVibes","vibeNames","vibeName","vibeCheckHistory","vibeCheck","reduce","previousValue","score","vibesScored","i","vibesSorted","sort","a","b","onlyPreferredVibes","getVibesFromVibeTimes","vibeTimes","length","name","getRelatedVibes","similarity","relatedVibes","vibesWithRelated","flatMap","allRelated","related","concat","alias","similarVibes","mostSimilar","push","Set","yourvibe_scale_v1","y","normalize_all","val","min","max","scale_low","scale_high","LinearScale","domain","range","lin_scale","percent_yourvibe","placevibes","my_vibes_fraction","yourvibe","related_vibes","fraction_counter","vibe_m","vibe_p","remaining_place_vibes","remaining_score_normalized","remaining_score","Math","log10","yourvibe_rounded","round"],"mappings":"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"}